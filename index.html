<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #000;
    }
    
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 100;
    }
    
    #crosshair::before {
      content: '';
      position: absolute;
      width: 4px;
      height: 24px;
      background: white;
      left: -2px;
      top: -12px;
      box-shadow: 0 0 4px black;
    }
    
    #crosshair::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 4px;
      background: white;
      left: -12px;
      top: -2px;
      box-shadow: 0 0 4px black;
    }
    
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.85);
      padding: 18px 22px;
      border-radius: 12px;
      font-size: 15px;
      line-height: 1.7;
      z-index: 100;
      border: 2px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
    }
    
    #ui h2 {
      font-size: 20px;
      margin-bottom: 12px;
    }
    
    #ui .hint {
      margin-top: 14px;
      font-size: 13px;
      opacity: 0.85;
      font-style: italic;
    }
    
    #hotbar {
      position: fixed;
      bottom: 45px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 14px;
      background: rgba(0,0,0,0.85);
      border-radius: 14px;
      border: 3px solid rgba(255,255,255,0.25);
      backdrop-filter: blur(10px);
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .block-slot {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      cursor: pointer;
      position: relative;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
      transition: all 0.2s;
      border: 4px solid rgba(255,255,255,0.25);
    }
    
    .block-slot.selected {
      border: 4px solid white;
      box-shadow: 0 0 20px rgba(255,255,255,0.8), inset 0 2px 8px rgba(255,255,255,0.4);
      transform: scale(1.15) translateY(-4px);
    }
    
    .block-slot .number {
      position: absolute;
      top: -26px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: bold;
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 4px 8px;
      border-radius: 6px;
      white-space: nowrap;
      text-shadow: 0 2px 4px black;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    /* Mobile controls */
    .mobile-controls {
      display: none;
    }
    
    @media (max-width: 768px), (pointer: coarse) {
      #ui {
        font-size: 14px;
        padding: 14px 18px;
        right: 20px;
      }
      
      #hotbar {
        bottom: 150px;
      }
      
      .mobile-controls {
        display: block;
      }
    }
    
    #joystick {
      position: fixed;
      bottom: 35px;
      left: 35px;
      width: 150px;
      height: 150px;
      background: rgba(255,255,255,0.12);
      border: 5px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 65px;
      height: 65px;
      background: rgba(255,255,255,0.5);
      border: 4px solid rgba(255,255,255,0.8);
      border-radius: 50%;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      transition: transform 0.1s ease-out;
    }
    
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #jumpBtn {
      bottom: 120px;
      right: 35px;
      width: 100px;
      height: 100px;
      background: linear-gradient(145deg, rgba(80,220,80,0.7), rgba(40,180,40,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 17px;
    }
    
    #placeBtn {
      bottom: 35px;
      right: 155px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80,180,255,0.7), rgba(40,140,220,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 15px;
    }
    
    #breakBtn {
      bottom: 35px;
      right: 35px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(255,80,80,0.7), rgba(220,40,40,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 15px;
    }
    
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 65%;
      height: 75%;
      z-index: 99;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div id="crosshair"></div>
  
  <div id="ui">
    <h2>‚õèÔ∏è Minecraft Clone</h2>
    <div>üéÆ <strong>WASD</strong> - Move</div>
    <div>üèÉ <strong>Shift</strong> - Sprint</div>
    <div>‚¨ÜÔ∏è <strong>Space</strong> - Jump</div>
    <div>üñ±Ô∏è <strong>Mouse</strong> - Look</div>
    <div>‚ùå <strong>Left Click</strong> - Break</div>
    <div>‚úÖ <strong>Right Click</strong> - Place</div>
    <div>üî¢ <strong>1-8</strong> - Select Block</div>
    <div class="hint">üí° Click to lock cursor</div>
  </div>
  
  <div id="hotbar"></div>
  
  <div class="mobile-controls">
    <div id="joystick">
      <div id="joystick-knob"></div>
    </div>
    <div id="jumpBtn" class="mobile-btn">JUMP</div>
    <div id="placeBtn" class="mobile-btn">PLACE</div>
    <div id="breakBtn" class="mobile-btn">BREAK</div>
    <div id="lookArea"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 18, 8);

    // Renderer
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ 
      canvas: canvas,
      antialias: true,
      alpha: false
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff9e6, 0.85);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.left = -60;
    sunLight.shadow.camera.right = 60;
    sunLight.shadow.camera.top = 60;
    sunLight.shadow.camera.bottom = -60;
    scene.add(sunLight);

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x6B5D3F, 0.5);
    scene.add(hemiLight);

    // Materials
    const createMaterial = (color) => {
      return new THREE.MeshLambertMaterial({ 
        color: color,
        flatShading: true
      });
    };

    const blockMaterials = {
      grass: [
        createMaterial(0x4a7a2f), 
        createMaterial(0x4a7a2f), 
        createMaterial(0x5cb230), 
        createMaterial(0x7d5f35), 
        createMaterial(0x4a7a2f), 
        createMaterial(0x4a7a2f)
      ],
      dirt: createMaterial(0x7d5f35),
      stone: createMaterial(0x7a7a7a),
      wood: createMaterial(0x6b4423),
      leaves: new THREE.MeshLambertMaterial({ 
        color: 0x2d8b2d, 
        transparent: true, 
        opacity: 0.88,
        flatShading: true
      }),
      sand: createMaterial(0xe8c998),
      water: new THREE.MeshLambertMaterial({ 
        color: 0x3d8fd1, 
        transparent: true, 
        opacity: 0.75
      }),
      cobblestone: createMaterial(0x5a5a5a),
      planks: createMaterial(0xb8935f)
    };

    // World
    const world = new Map();
    let selectedBlock = 'grass';

    function getBlockKey(x, y, z) {
      return `${x}|${y}|${z}`;
    }

    function simpleNoise(x, z, seed = 0) {
      const n = Math.sin(x * 0.1 + seed) * Math.cos(z * 0.1 + seed) * 50000;
      return n - Math.floor(n);
    }

    function getHeight(x, z) {
      const base = simpleNoise(x, z) * 5;
      const detail = simpleNoise(x * 2, z * 2, 10) * 2;
      return Math.floor(base + detail) + 6;
    }

    function addBlock(x, y, z, type) {
      const key = getBlockKey(x, y, z);
      if (world.has(key)) return;

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = blockMaterials[type];
      const mesh = new THREE.Mesh(geometry, material);
      
      mesh.position.set(x, y, z);
      mesh.castShadow = type !== 'water';
      mesh.receiveShadow = true;
      
      scene.add(mesh);
      world.set(key, { mesh, type });
    }

    function removeBlock(x, y, z) {
      const key = getBlockKey(x, y, z);
      const block = world.get(key);
      
      if (block && block.type !== 'water') {
        scene.remove(block.mesh);
        block.mesh.geometry.dispose();
        world.delete(key);
      }
    }

    function placeTree(x, baseY, z) {
      for (let y = 0; y < 5; y++) {
        addBlock(x, baseY + y, z, 'wood');
      }
      
      const leafY = baseY + 4;
      for (let dy = 0; dy <= 3; dy++) {
        const radius = dy === 3 ? 0 : (dy < 2 ? 2 : 1);
        for (let dx = -radius; dx <= radius; dx++) {
          for (let dz = -radius; dz <= radius; dz++) {
            if (dx === 0 && dz === 0 && dy < 2) continue;
            if (Math.abs(dx) + Math.abs(dz) <= radius) {
              addBlock(x + dx, leafY + dy, z + dz, 'leaves');
            }
          }
        }
      }
    }

    // Generate world
    const size = 20;
    const waterLevel = 5;

    for (let x = -size; x <= size; x++) {
      for (let z = -size; z <= size; z++) {
        const height = getHeight(x, z);
        const isBeach = height <= waterLevel + 1;
        
        for (let y = 0; y <= height; y++) {
          let type;
          if (y === height) {
            type = isBeach ? 'sand' : 'grass';
          } else if (y > height - 2) {
            type = isBeach ? 'sand' : 'dirt';
          } else {
            type = 'stone';
          }
          addBlock(x, y, z, type);
        }
        
        if (height < waterLevel) {
          for (let y = height + 1; y <= waterLevel; y++) {
            addBlock(x, y, z, 'water');
          }
        }
        
        if (!isBeach && height > waterLevel + 1 && Math.random() < 0.01 && x % 5 === 0 && z % 5 === 0) {
          placeTree(x, height + 1, z);
        }
      }
    }

    // Player
    const player = {
      position: new THREE.Vector3(0, 20, 8),
      velocity: new THREE.Vector3(0, 0, 0),
      height: 1.7,
      radius: 0.3,
      speed: 0.15,
      sprintSpeed: 0.25,
      jumpForce: 0.2,
      gravity: 0.015,
      onGround: false,
      bobPhase: 0
    };

    // Input
    const keys = {};
    const mouse = { x: 0, y: 0, locked: false };
    const joystick = { active: false, deltaX: 0, deltaY: 0 };
    const lookTouch = { active: false, lastX: 0, lastY: 0 };
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // Event listeners
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      const num = parseInt(e.key);
      if (num >= 1 && num <= 8) {
        const types = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'cobblestone', 'planks'];
        selectedBlock = types[num - 1];
        updateHotbar();
      }
    });

    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('mousemove', (e) => {
      if (!mouse.locked) return;
      mouse.x += e.movementX * 0.002;
      mouse.y -= e.movementY * 0.002;
      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
    });

    canvas.addEventListener('click', () => {
      if (!isMobile && !mouse.locked) {
        canvas.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      mouse.locked = document.pointerLockElement === canvas;
    });

    // Raycasting
    const raycaster = new THREE.Raycaster();
    raycaster.far = 6;

    function handleBlockAction(isBreak) {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      
      const intersects = [];
      world.forEach(({ mesh, type }) => {
        if (type === 'water') return;
        const hit = raycaster.intersectObject(mesh);
        if (hit.length > 0) {
          intersects.push({ ...hit[0], mesh });
        }
      });

      intersects.sort((a, b) => a.distance - b.distance);

      if (intersects.length > 0) {
        const { face, mesh } = intersects[0];
        const pos = mesh.position;

        if (isBreak) {
          removeBlock(pos.x, pos.y, pos.z);
        } else {
          const normal = face.normal;
          const newPos = pos.clone().add(normal);
          addBlock(newPos.x, newPos.y, newPos.z, selectedBlock);
        }
      }
    }

    document.addEventListener('mousedown', (e) => {
      if (!mouse.locked) return;
      e.preventDefault();
      handleBlockAction(e.button === 0);
    });

    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Mobile controls
    if (isMobile) {
      const joystickEl = document.getElementById('joystick');
      const knob = document.getElementById('joystick-knob');
      
      joystickEl.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystick.active = true;
      });

      joystickEl.addEventListener('touchmove', (e) => {
        if (!joystick.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = joystickEl.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const deltaX = touch.clientX - centerX;
        const deltaY = touch.clientY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDist = 50;
        
        if (distance > maxDist) {
          const angle = Math.atan2(deltaY, deltaX);
          joystick.deltaX = Math.cos(angle);
          joystick.deltaY = Math.sin(angle);
        } else {
          joystick.deltaX = deltaX / maxDist;
          joystick.deltaY = deltaY / maxDist;
        }
        
        knob.style.transform = `translate(-50%, -50%) translate(${joystick.deltaX * 50}px, ${joystick.deltaY * 50}px)`;
      });

      joystickEl.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.deltaX = 0;
        joystick.deltaY = 0;
        knob.style.transform = 'translate(-50%, -50%)';
      });

      const lookArea = document.getElementById('lookArea');
      lookArea.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        lookTouch.active = true;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
      });

      lookArea.addEventListener('touchmove', (e) => {
        if (!lookTouch.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const deltaX = (touch.clientX - lookTouch.lastX) * 0.004;
        const deltaY = (touch.clientY - lookTouch.lastY) * 0.004;
        
        mouse.x += deltaX;
        mouse.y -= deltaY;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
        
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
      });

      lookArea.addEventListener('touchend', () => {
        lookTouch.active = false;
      });

      document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (player.onGround) player.velocity.y = player.jumpForce;
      });

      document.getElementById('placeBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleBlockAction(false);
      });

      document.getElementById('breakBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleBlockAction(true);
      });
    }

    // Collision
    function checkCollision(pos) {
      const box = new THREE.Box3(
        new THREE.Vector3(pos.x - player.radius, pos.y, pos.z - player.radius),
        new THREE.Vector3(pos.x + player.radius, pos.y + player.height, pos.z + player.radius)
      );

      for (const { mesh, type } of world.values()) {
        if (type === 'water') continue;
        const blockBox = new THREE.Box3().setFromObject(mesh);
        if (box.intersectsBox(blockBox)) return true;
      }
      return false;
    }

    // Update
    function update() {
      player.velocity.y -= player.gravity;

      const moveDir = new THREE.Vector3();
      let moving = false;
      const speed = keys['ShiftLeft'] ? player.sprintSpeed : player.speed;

      if (isMobile) {
        if (Math.abs(joystick.deltaX) > 0.1 || Math.abs(joystick.deltaY) > 0.1) {
          moveDir.x = joystick.deltaX * speed;
          moveDir.z = joystick.deltaY * speed;
          moving = true;
        }
      } else {
        if (keys['KeyW']) { moveDir.z -= speed; moving = true; }
        if (keys['KeyS']) { moveDir.z += speed; moving = true; }
        if (keys['KeyA']) { moveDir.x -= speed; moving = true; }
        if (keys['KeyD']) { moveDir.x += speed; moving = true; }
        if (keys['Space'] && player.onGround) {
          player.velocity.y = player.jumpForce;
        }
      }

      moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouse.x);
      const newPos = player.position.clone().add(player.velocity).add(moveDir);

      const groundCheck = newPos.clone();
      groundCheck.y -= 0.1;
      
      if (checkCollision(groundCheck)) {
        player.onGround = true;
        player.velocity.y = 0;
        newPos.y = Math.round(player.position.y);
      } else {
        player.onGround = false;
      }

      const horizCheck = player.position.clone();
      horizCheck.x = newPos.x;
      horizCheck.z = newPos.z;
      
      if (!checkCollision(horizCheck)) {
        player.position.x = newPos.x;
        player.position.z = newPos.z;
      }

      if (!checkCollision(newPos) || player.velocity.y < 0) {
        player.position.y = newPos.y;
      }

      let bob = 0;
      if (moving && player.onGround) {
        player.bobPhase += 0.2;
        bob = Math.sin(player.bobPhase) * 0.1;
      }

      camera.position.copy(player.position);
      camera.position.y += player.height - 0.3 + bob;
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouse.x;
      camera.rotation.x = mouse.y;
    }

    // Hotbar
    const blocks = [
      { name: 'grass', color: '#5cb230' },
      { name: 'dirt', color: '#7d5f35' },
      { name: 'stone', color: '#7a7a7a' },
      { name: 'wood', color: '#6b4423' },
      { name: 'leaves', color: '#2d8b2d' },
      { name: 'sand', color: '#e8c998' },
      { name: 'cobblestone', color: '#5a5a5a' },
      { name: 'planks', color: '#b8935f' }
    ];

    const hotbar = document.getElementById('hotbar');
    blocks.forEach((block, i) => {
      const slot = document.createElement('div');
      slot.className = 'block-slot' + (block.name === selectedBlock ? ' selected' : '');
      slot.style.background = block.color;
      slot.innerHTML = `<div class="number">${i + 1}</div>`;
      slot.addEventListener('click', () => {
        selectedBlock = block.name;
        updateHotbar();
      });
      hotbar.appendChild(slot);
    });

    function updateHotbar() {
      const slots = hotbar.querySelectorAll('.block-slot');
      slots.forEach((slot, i) => {
        slot.className = 'block-slot' + (blocks[i].name === selectedBlock ? ' selected' : '');
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
