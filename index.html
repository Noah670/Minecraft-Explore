<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: Arial, sans-serif; background: #87CEEB; }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      border-radius: 5px;
      max-width: 220px;
      border: 1px solid rgba(0, 255, 0, 0.3);
      transition: all 0.3s;
    }
    #status.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

    #close-status {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 0, 0, 0.7);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: bold;
      line-height: 1;
      padding: 0;
    }
    #close-status:hover { background: rgba(255, 50, 50, 1); }

    #toggle-status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      border: 1px solid rgba(0, 255, 0, 0.5);
      padding: 6px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      z-index: 1001;
      display: none;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      z-index: 100;
    }
    #crosshair::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 20px;
      background: white;
      left: 8px;
      box-shadow: 0 0 3px black;
    }
    #crosshair::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 3px;
      background: white;
      top: 8px;
      box-shadow: 0 0 3px black;
    }

    #ui {
      position: fixed;
      top: 50px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.85);
      padding: 12px 15px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 100;
      max-width: 220px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s;
    }
    #ui.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }
    #ui h3 { margin-bottom: 8px; font-size: 15px; }
    #ui div { margin: 4px 0; font-size: 12px; }

    #close-ui {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      padding: 0;
      font-weight: bold;
    }

    #hotbar {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      z-index: 100;
    }

    .block-slot {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .block-slot.selected {
      border-color: white;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .block-slot .num {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 5px;
      border-radius: 3px;
    }

    #mobile-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      display: none;
    }
    #joystick {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(255, 255, 255, 0.15);
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
      backdrop-filter: blur(5px);
    }
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 3px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      transition: transform 0.1s ease-out;
    }
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 14px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #jumpBtn {
      bottom: 110px;
      right: 30px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80, 220, 80, 0.7), rgba(40, 180, 40, 0.7));
    }
    #placeBtn {
      bottom: 30px;
      right: 140px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(80, 180, 255, 0.7), rgba(40, 140, 220, 0.7));
    }
    #breakBtn {
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(255, 80, 80, 0.7), rgba(220, 40, 40, 0.7));
    }
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 60%;
      height: 70%;
      pointer-events: auto;
      touch-action: none;
    }

    @media (max-width: 768px), (pointer: coarse) {
      #hotbar { bottom: 160px; }
      #mobile-controls { display: block; }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="status">
    <button id="close-status">√ó</button>
    <div>Status: <span id="status-text">Initializing...</span></div>
    <div>Renderer: <span id="renderer-status">Not started</span></div>
    <div>World: <span id="world-status">Not generated</span></div>
    <div>Player: <span id="player-pos">X:0 Y:0 Z:0</span></div>
    <div>On Ground: <span id="on-ground">No</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>

  <button id="toggle-status">Show Debug</button>

  <div id="crosshair"></div>

  <div id="ui">
    <button id="close-ui">√ó</button>
    <h3>‚õèÔ∏è Controls</h3>
    <div>üéÆ WASD - Move</div>
    <div>üèÉ Shift - Sprint</div>
    <div>‚¨ÜÔ∏è Space - Jump</div>
    <div>üñ±Ô∏è Mouse - Look</div>
    <div>üî® Left Click - Break</div>
    <div>üì¶ Right Click - Place</div>
    <div>üî¢ 1-5 - Select Block</div>
    <div style="margin-top:10px; font-size:11px; opacity:0.8;">Click screen to play</div>
  </div>

  <div id="hotbar"></div>

  <div id="mobile-controls">
    <div id="joystick"><div id="joystick-knob"></div></div>
    <button id="jumpBtn" class="mobile-btn">JUMP</button>
    <button id="placeBtn" class="mobile-btn">PLACE</button>
    <button id="breakBtn" class="mobile-btn">BREAK</button>
    <div id="lookArea"></div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    const statusText = document.getElementById('status-text');
    const rendererStatus = document.getElementById('renderer-status');
    const worldStatus = document.getElementById('world-status');
    const playerPos = document.getElementById('player-pos');
    const onGroundText = document.getElementById('on-ground');
    const fpsText = document.getElementById('fps');

    function log(message, type = 'info') {
      console[type === 'error' ? 'error' : 'log'](`[${type.toUpperCase()}] ${message}`);
      statusText.textContent = message;
    }

    let scene, camera, renderer;
    const world = new Map();
    const solidMeshes = [];
    const keys = {};
    const mouse = { x: 0, y: 0, locked: false };
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const joystick = { active: false, deltaX: 0, deltaY: 0 };
    const lookTouch = { active: false, lastX: 0, lastY: 0 };
    const raycaster = new THREE.Raycaster();
    raycaster.far = 6;

    const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'sand'];
    let selectedBlock = 'grass';

    const sharedGeometry = new THREE.BoxGeometry(1, 1, 1);
    const materials = {
      grass: new THREE.MeshLambertMaterial({ color: 0x7ac74f, flatShading: true }),
      dirt: new THREE.MeshLambertMaterial({ color: 0x8b6914, flatShading: true }),
      stone: new THREE.MeshLambertMaterial({ color: 0x888888, flatShading: true }),
      wood: new THREE.MeshLambertMaterial({ color: 0x8b5a2b, flatShading: true }),
      sand: new THREE.MeshLambertMaterial({ color: 0xf4d999, flatShading: true }),
      water: new THREE.MeshLambertMaterial({ color: 0x3d8fd1, transparent: true, opacity: 0.75 })
    };

    function getKey(x, y, z) { return `${x},${y},${z}`; }

    function addBlock(x, y, z, type) {
      const key = getKey(x, y, z);
      if (world.has(key)) return;
      const mesh = new THREE.Mesh(sharedGeometry, materials[type] || materials.stone);
      mesh.position.set(x, y, z);
      mesh.castShadow = type !== 'water';
      mesh.receiveShadow = true;
      mesh.userData.type = type;
      scene.add(mesh);
      world.set(key, { mesh, type });
      if (type !== 'water') solidMeshes.push(mesh);
    }

    function removeBlock(x, y, z) {
      const key = getKey(x, y, z);
      const block = world.get(key);
      if (!block || block.type === 'water') return;
      scene.remove(block.mesh);
      const index = solidMeshes.indexOf(block.mesh);
      if (index >= 0) solidMeshes.splice(index, 1);
      world.delete(key);
    }


    function renderFallback2D(reason) {
      const container = document.getElementById('canvas-container');
      container.innerHTML = '';
      const fallback = document.createElement('canvas');
      fallback.width = window.innerWidth;
      fallback.height = window.innerHeight;
      fallback.style.width = '100%';
      fallback.style.height = '100%';
      container.appendChild(fallback);

      const ctx = fallback.getContext('2d');
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, fallback.width, fallback.height);
      ctx.fillStyle = '#5cb230';
      ctx.fillRect(0, fallback.height * 0.6, fallback.width, fallback.height * 0.4);

      const tile = 24;
      for (let x = 0; x < fallback.width; x += tile) {
        for (let y = Math.floor(fallback.height * 0.6); y < fallback.height; y += tile) {
          ctx.fillStyle = (x / tile + y / tile) % 2 === 0 ? '#6ebd46' : '#5cad3c';
          ctx.fillRect(x, y, tile, tile);
        }
      }

      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(20, 20, 520, 110);
      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.fillText('3D mode unavailable on this device/browser.', 40, 55);
      ctx.font = '14px Arial';
      ctx.fillText('Fallback mode loaded so the world is still visible.', 40, 82);
      ctx.fillText(reason || 'WebGL renderer could not be initialized.', 40, 106);
    }

    function initThree() {
      log('Creating renderer...');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 40, 120);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 5);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;

      document.getElementById('canvas-container').appendChild(renderer.domElement);
      rendererStatus.textContent = 'Active';

      scene.add(new THREE.AmbientLight(0xffffff, 0.7));
      const light = new THREE.DirectionalLight(0xfff9e6, 1.0);
      light.position.set(50, 100, 50);
      light.castShadow = true;
      light.shadow.mapSize.set(2048, 2048);
      light.shadow.camera.left = -60;
      light.shadow.camera.right = 60;
      light.shadow.camera.top = 60;
      light.shadow.camera.bottom = -60;
      scene.add(light);
      scene.add(new THREE.DirectionalLight(0x8ec5fc, 0.3).position.set(-30, 20, -30));
    }

    function initWorld() {
      log('Generating world...');
      const size = isMobile ? 12 : 15;
      const waterLevel = 3;
      let count = 0;

      for (let x = -size; x <= size; x++) {
        for (let z = -size; z <= size; z++) {
          addBlock(x, 0, z, 'stone');
          count++;
        }
      }

      for (let x = -size; x <= size; x++) {
        for (let z = -size; z <= size; z++) {
          const height = Math.floor(Math.sin(x * 0.2) * Math.cos(z * 0.2) * 2 + Math.sin(x * 0.5) * Math.cos(z * 0.5)) + 4;
          for (let y = 1; y <= height; y++) {
            const type = y === height ? 'grass' : y >= height - 2 ? 'dirt' : 'stone';
            addBlock(x, y, z, type);
            count++;
          }
          if (height < waterLevel) {
            for (let y = height + 1; y <= waterLevel; y++) {
              addBlock(x, y, z, 'water');
              count++;
            }
          }
        }
      }

      worldStatus.textContent = `${count} blocks`;
      log(`World generated (${count} blocks)`, 'success');
    }

    const player = {
      position: new THREE.Vector3(0, 10, 0),
      velocity: new THREE.Vector3(),
      height: 1.7,
      radius: 0.4,
      speed: 0.15,
      sprintSpeed: 0.23,
      jumpForce: 0.2,
      gravity: 0.02,
      onGround: false,
      bobPhase: 0
    };

    function collides(pos) {
      const box = new THREE.Box3(
        new THREE.Vector3(pos.x - player.radius, pos.y, pos.z - player.radius),
        new THREE.Vector3(pos.x + player.radius, pos.y + player.height, pos.z + player.radius)
      );
      for (const mesh of solidMeshes) {
        const meshBox = new THREE.Box3().setFromObject(mesh);
        if (box.intersectsBox(meshBox)) return true;
      }
      return false;
    }

    function performBlockAction(isBreak) {
      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      raycaster.set(camera.position, direction);
      const hits = raycaster.intersectObjects(solidMeshes, false);
      if (!hits.length) return;

      const hit = hits[0];
      const pos = hit.object.position;

      if (isBreak) {
        removeBlock(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z));
      } else {
        const placePos = pos.clone().add(hit.face.normal);
        addBlock(Math.round(placePos.x), Math.round(placePos.y), Math.round(placePos.z), selectedBlock);
      }
    }

    function initInput() {
      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        const num = Number(e.key);
        if (num >= 1 && num <= blockTypes.length) {
          selectedBlock = blockTypes[num - 1];
          updateHotbar();
        }
      });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      document.addEventListener('mousemove', (e) => {
        if (!mouse.locked) return;
        mouse.x += e.movementX * 0.002;
        mouse.y += e.movementY * 0.002;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
      });

      renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock?.());
      document.addEventListener('pointerlockchange', () => {
        mouse.locked = document.pointerLockElement === renderer.domElement;
      });

      document.addEventListener('mousedown', (e) => {
        if (!mouse.locked) return;
        e.preventDefault();
        if (e.button === 0) performBlockAction(true);
        if (e.button === 2) performBlockAction(false);
      });
      document.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    function initMobileControls() {
      if (!isMobile) return;
      document.getElementById('mobile-controls').style.display = 'block';
      const joystickEl = document.getElementById('joystick');
      const knob = document.getElementById('joystick-knob');

      joystickEl.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; });
      joystickEl.addEventListener('touchmove', (e) => {
        if (!joystick.active) return;
        e.preventDefault();
        const t = e.touches[0];
        const rect = joystickEl.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = t.clientX - cx;
        const dy = t.clientY - cy;
        const dist = Math.hypot(dx, dy);
        const max = 50;
        if (dist > max) {
          const angle = Math.atan2(dy, dx);
          joystick.deltaX = Math.cos(angle);
          joystick.deltaY = Math.sin(angle);
        } else {
          joystick.deltaX = dx / max;
          joystick.deltaY = dy / max;
        }
        knob.style.transform = `translate(-50%, -50%) translate(${joystick.deltaX * 50}px, ${joystick.deltaY * 50}px)`;
      });
      joystickEl.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.deltaX = 0;
        joystick.deltaY = 0;
        knob.style.transform = 'translate(-50%, -50%)';
      });

      const lookArea = document.getElementById('lookArea');
      lookArea.addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        lookTouch.active = true;
        lookTouch.lastX = t.clientX;
        lookTouch.lastY = t.clientY;
      });
      lookArea.addEventListener('touchmove', (e) => {
        if (!lookTouch.active) return;
        e.preventDefault();
        const t = e.touches[0];
        mouse.x += (t.clientX - lookTouch.lastX) * 0.004;
        mouse.y += (t.clientY - lookTouch.lastY) * 0.004;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
        lookTouch.lastX = t.clientX;
        lookTouch.lastY = t.clientY;
      });
      lookArea.addEventListener('touchend', () => { lookTouch.active = false; });

      document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (player.onGround) player.velocity.y = player.jumpForce;
      });
      document.getElementById('placeBtn').addEventListener('touchstart', (e) => { e.preventDefault(); performBlockAction(false); });
      document.getElementById('breakBtn').addEventListener('touchstart', (e) => { e.preventDefault(); performBlockAction(true); });
    }

    function initHotbar() {
      const hotbar = document.getElementById('hotbar');
      hotbar.innerHTML = '';
      blockTypes.forEach((type, i) => {
        const slot = document.createElement('div');
        slot.className = 'block-slot' + (i === 0 ? ' selected' : '');
        slot.style.background = `#${materials[type].color.getHexString()}`;
        slot.innerHTML = `<div class="num">${i + 1}</div>`;
        slot.addEventListener('click', () => { selectedBlock = type; updateHotbar(); });
        hotbar.appendChild(slot);
      });
    }

    function updateHotbar() {
      const slots = document.querySelectorAll('.block-slot');
      slots.forEach((slot, i) => {
        slot.className = 'block-slot' + (blockTypes[i] === selectedBlock ? ' selected' : '');
      });
    }

    function updatePlayer(dt) {
      const move = new THREE.Vector3();
      let moving = false;
      const speed = (keys['ShiftLeft'] ? player.sprintSpeed : player.speed) * dt * 60;

      if (isMobile) {
        if (Math.abs(joystick.deltaX) > 0.1 || Math.abs(joystick.deltaY) > 0.1) {
          move.x += joystick.deltaX * speed;
          move.z += joystick.deltaY * speed;
          moving = true;
        }
      } else {
        if (keys['KeyW']) { move.z -= speed; moving = true; }
        if (keys['KeyS']) { move.z += speed; moving = true; }
        if (keys['KeyA']) { move.x -= speed; moving = true; }
        if (keys['KeyD']) { move.x += speed; moving = true; }
      }

      if (keys['Space'] && player.onGround && !isMobile) {
        player.velocity.y = player.jumpForce;
        player.onGround = false;
      }

      move.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouse.x);
      player.velocity.y -= player.gravity * dt * 60;

      const next = player.position.clone();
      next.x += move.x;
      next.z += move.z;

      const xzTry = player.position.clone();
      xzTry.x = next.x;
      if (!collides(xzTry)) player.position.x = xzTry.x;
      xzTry.x = player.position.x;
      xzTry.z = next.z;
      if (!collides(xzTry)) player.position.z = xzTry.z;

      const yTry = player.position.clone();
      yTry.y += player.velocity.y;
      if (!collides(yTry)) {
        player.position.y = yTry.y;
        player.onGround = false;
      } else {
        if (player.velocity.y < 0) player.onGround = true;
        player.velocity.y = 0;
      }

      if (player.position.y < -10) {
        player.position.set(0, 10, 0);
        player.velocity.set(0, 0, 0);
      }

      if (moving && player.onGround) player.bobPhase += 0.2;
      const bob = moving && player.onGround ? Math.sin(player.bobPhase) * 0.08 : 0;

      camera.position.copy(player.position);
      camera.position.y += player.height - 0.2 + bob;
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouse.x;
      camera.rotation.x = mouse.y;

      playerPos.textContent = `X:${player.position.x.toFixed(1)} Y:${player.position.y.toFixed(1)} Z:${player.position.z.toFixed(1)}`;
      onGroundText.textContent = player.onGround ? 'Yes' : 'No';
    }

    function initDebugUI() {
      const status = document.getElementById('status');
      const toggle = document.getElementById('toggle-status');
      const ui = document.getElementById('ui');

      document.getElementById('close-status').addEventListener('click', () => {
        status.classList.add('hidden');
        toggle.style.display = 'block';
      });
      toggle.addEventListener('click', () => {
        status.classList.remove('hidden');
        toggle.style.display = 'none';
      });
      document.getElementById('close-ui').addEventListener('click', () => {
        ui.classList.add('hidden');
      });
    }

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let lastTime = performance.now();
    let frameCount = 0;
    let fpsTimer = 0;

    function animate(time) {
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;

      updatePlayer(dt);
      renderer.render(scene, camera);

      frameCount++;
      fpsTimer += dt;
      if (fpsTimer >= 1) {
        fpsText.textContent = String(frameCount);
        frameCount = 0;
        fpsTimer = 0;
      }
    }

    function boot() {
      try {
        log('Initializing...');
        initThree();
        initWorld();
        initInput();
        initMobileControls();
        initHotbar();
        initDebugUI();
        window.addEventListener('resize', resize);
        log('Game ready. Click screen to lock cursor.', 'success');
        animate(performance.now());
      } catch (error) {
        rendererStatus.textContent = 'Failed';
        worldStatus.textContent = 'Fallback 2D';
        log(`Startup failed: ${error.message}`, 'error');
        renderFallback2D(error.message);
      }
    }

    boot();
  </script>
</body>
</html>
