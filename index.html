<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: Arial, sans-serif; background: #87CEEB; }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      border-radius: 5px;
      max-width: 220px;
      border: 1px solid rgba(0, 255, 0, 0.3);
      transition: all 0.3s;
    }
    #status.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

    #close-status {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 0, 0, 0.7);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: bold;
      line-height: 1;
      padding: 0;
    }
    #close-status:hover { background: rgba(255, 50, 50, 1); }

    #toggle-status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      border: 1px solid rgba(0, 255, 0, 0.5);
      padding: 6px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      z-index: 1001;
      display: none;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      z-index: 100;
    }
    #crosshair::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 20px;
      background: white;
      left: 8px;
      box-shadow: 0 0 3px black;
    }
    #crosshair::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 3px;
      background: white;
      top: 8px;
      box-shadow: 0 0 3px black;
    }

    #ui {
      position: fixed;
      top: 50px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.85);
      padding: 12px 15px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 100;
      max-width: 220px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s;
    }
    #ui.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }
    #ui h3 { margin-bottom: 8px; font-size: 15px; }
    #ui div { margin: 4px 0; font-size: 12px; }

    #close-ui {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      padding: 0;
      font-weight: bold;
    }

    #status {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 18px 26px;
      border-radius: 12px;
      font-size: 16px;
      text-align: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
      max-width: 320px;
    }

    #status.hidden {
      display: none;
    }
    
    #hotbar {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      z-index: 100;
    }

    .block-slot {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .block-slot.selected {
      border-color: white;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .block-slot .num {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 5px;
      border-radius: 3px;
    }

    #mobile-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      display: none;
    }
    #joystick {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(255, 255, 255, 0.15);
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
      backdrop-filter: blur(5px);
    }
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 3px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      transition: transform 0.1s ease-out;
    }
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 14px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #jumpBtn {
      bottom: 110px;
      right: 30px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80, 220, 80, 0.7), rgba(40, 180, 40, 0.7));
    }
    #placeBtn {
      bottom: 30px;
      right: 140px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(80, 180, 255, 0.7), rgba(40, 140, 220, 0.7));
    }
    #breakBtn {
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(255, 80, 80, 0.7), rgba(220, 40, 40, 0.7));
    }
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 60%;
      height: 70%;
      pointer-events: auto;
      touch-action: none;
    }

    @media (max-width: 768px), (pointer: coarse) {
      #hotbar { bottom: 160px; }
      #mobile-controls { display: block; }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="status">
    <button id="close-status">√ó</button>
    <div>Status: <span id="status-text">Initializing...</span></div>
    <div>Renderer: <span id="renderer-status">Not started</span></div>
    <div>World: <span id="world-status">Not generated</span></div>
    <div>Player: <span id="player-pos">X:0 Y:0 Z:0</span></div>
    <div>On Ground: <span id="on-ground">No</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>

  <button id="toggle-status">Show Debug</button>

  <div id="crosshair"></div>

  <div id="ui">
    <button id="close-ui">√ó</button>
    <h3>‚õèÔ∏è Controls</h3>
    <div>üéÆ WASD - Move</div>
    <div>üèÉ Shift - Sprint</div>
    <div>‚¨ÜÔ∏è Space - Jump</div>
    <div>üñ±Ô∏è Mouse - Look</div>
    <div>üî® Left Click - Break</div>
    <div>üì¶ Right Click - Place</div>
    <div>üî¢ 1-5 - Select Block</div>
    <div style="margin-top:10px; font-size:11px; opacity:0.8;">Click screen to play</div>
  </div>

  <div id="hotbar"></div>

  <div id="status">Loading world...</div>
  
  <!-- Mobile Controls -->
  <div id="mobile-controls" style="display: none;">
    <div id="joystick">
      <div id="joystick-knob"></div>
    </div>
    <button id="jumpBtn" class="mobile-btn">JUMP</button>
    <button id="placeBtn" class="mobile-btn">PLACE</button>
    <button id="breakBtn" class="mobile-btn">BREAK</button>
    <div id="lookArea"></div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('gameCanvas');
    const hotbar = document.getElementById('hotbar');
    const showStatus = (message) => {
      statusEl.textContent = message;
      statusEl.classList.remove('hidden');
    };
    const hideStatus = () => statusEl.classList.add('hidden');

    const reportError = (message, error) => {
      const detail = error && error.message ? `\n${error.message}` : '';
      showStatus(`${message}${detail}`);
      console.error(message, error);
    };

    window.addEventListener('error', (event) => {
      reportError('An error occurred while loading the world.', event.error || event.message);
    });
    renderer.setClearColor(0x87CEEB, 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff9e6, 0.85);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.left = -60;
    sunLight.shadow.camera.right = 60;
    sunLight.shadow.camera.top = 60;
    sunLight.shadow.camera.bottom = -60;
    scene.add(sunLight);

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x6B5D3F, 0.5);
    scene.add(hemiLight);

     
    // Materials
    const createMaterial = (color) => {
      return new THREE.MeshLambertMaterial({ 
        color: color,
        flatShading: true
      });
    };

    const showStatus = (message) => {
      statusEl.textContent = message;
      statusEl.classList.remove('hidden');
    };
    
    const sharedGeometry = new THREE.BoxGeometry(1, 1, 1);

    const hideStatus = () => statusEl.classList.add('hidden');
    // World
    const world = new Map();
    let selectedBlock = 'grass';
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);

    const reportError = (message, error) => {
      const detail = error && error.message ? `
${error.message}` : '';
      showStatus(`${message}${detail}`);
      console.error(message, error);
    };

    const scriptSources = [
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
      'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
      'https://unpkg.com/three@0.128.0/build/three.min.js'
    ];

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(script);
      });
    }

    async function loadThree() {
      for (const src of scriptSources) {
        try {
          await loadScript(src);
          if (window.THREE) return window.THREE;
        } catch (error) {
          console.warn(error);
        }
      }
      throw new Error('Unable to load Three.js from all configured CDNs.');
    }

    function isWebGLAvailable() {
      try {
        const testCanvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (
          testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl')
        ));
      } catch (error) {
        return false;
    const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

    function addBlock(x, y, z, type) {
      const key = getKey(x, y, z);
      if (world.has(key)) return;

      const material = blockMaterials[type];
      const mesh = new THREE.Mesh(blockGeometry, material);
      
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.type = type;
      scene.add(mesh);
      world.set(key, { mesh, type });
      if (type !== 'water') solidMeshes.push(mesh);
    }
    
    function removeBlock(x, y, z) {
      const key = getKey(x, y, z);
      const block = world.get(key);
      
      if (block) {
        scene.remove(block.mesh);
        world.delete(key);
      }

      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(20, 20, 520, 110);
      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.fillText('3D mode unavailable on this device/browser.', 40, 55);
      ctx.font = '14px Arial';
      ctx.fillText('Fallback mode loaded so the world is still visible.', 40, 82);
      ctx.fillText(reason || 'WebGL renderer could not be initialized.', 40, 106);
    }

    function getBlockKey(x, y, z) {
      return `${x}|${y}|${z}`;
    }

    function createGame(THREE) {
      if (!isWebGLAvailable()) {
        showStatus('WebGL is unavailable. Enable hardware acceleration or use a modern browser.');
        return;
    // Generate world
    const size = isMobile ? 14 : 20;
    const waterLevel = 5;

    for (let x = -size; x <= size; x++) {
      for (let z = -size; z <= size; z++) {
        const height = getHeight(x, z);
        const isBeach = height <= waterLevel + 1;
        
        for (let y = 0; y <= height; y++) {
          let type;
          if (y === height) {
            type = isBeach ? 'sand' : 'grass';
          } else if (y > height - 2) {
            type = isBeach ? 'sand' : 'dirt';
          } else {
            type = 'stone';
          }
          if (height < waterLevel) {
            for (let y = height + 1; y <= waterLevel; y++) {
              addBlock(x, y, z, 'water');
              count++;
            }
          }
        }
      }

      showStatus('Building world...');

    // Input
    const keys = {};
    const mouse = { x: 0, y: 0, locked: false };
    const joystick = { active: false, deltaX: 0, deltaY: 0 };
    const lookTouch = { active: false, lastX: 0, lastY: 0 };
    // Event listeners
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      const num = parseInt(e.key);
      if (num >= 1 && num <= 8) {
        const types = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'cobblestone', 'planks'];
        selectedBlock = types[num - 1];
        updateHotbar();
      }
      return false;
    }

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setClearColor(0x87CEEB, 1);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);

      canvas.addEventListener('webglcontextlost', (event) => {
        event.preventDefault();
        showStatus('WebGL context lost. Refresh to restore rendering.');
      });

      scene.add(new THREE.AmbientLight(0xffffff, 0.65));
      const sun = new THREE.DirectionalLight(0xfff9e6, 0.9);
      sun.position.set(60, 90, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024, 1024);
      scene.add(sun);

      const world = new Map();
      const collidableMeshes = [];
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const materials = {
        grassTop: new THREE.MeshLambertMaterial({ color: 0x5cb230 }),
        grassSide: new THREE.MeshLambertMaterial({ color: 0x4a7a2f }),
        dirt: new THREE.MeshLambertMaterial({ color: 0x7d5f35 }),
        stone: new THREE.MeshLambertMaterial({ color: 0x7a7a7a }),
        wood: new THREE.MeshLambertMaterial({ color: 0x6b4423 }),
        leaves: new THREE.MeshLambertMaterial({ color: 0x2d8b2d, transparent: true, opacity: 0.9 }),
        sand: new THREE.MeshLambertMaterial({ color: 0xe8c998 }),
        cobblestone: new THREE.MeshLambertMaterial({ color: 0x5a5a5a }),
        planks: new THREE.MeshLambertMaterial({ color: 0xb8935f }),
        water: new THREE.MeshLambertMaterial({ color: 0x3d8fd1, transparent: true, opacity: 0.75 })
      };

      const blockMaterialByType = {
        grass: [materials.grassSide, materials.grassSide, materials.grassTop, materials.dirt, materials.grassSide, materials.grassSide],
        dirt: materials.dirt,
        stone: materials.stone,
        wood: materials.wood,
        leaves: materials.leaves,
        sand: materials.sand,
        cobblestone: materials.cobblestone,
        planks: materials.planks,
        water: materials.water
      };

      function addBlock(x, y, z, type) {
        const key = getBlockKey(x, y, z);
        if (world.has(key)) return;

        const mesh = new THREE.Mesh(blockGeometry, blockMaterialByType[type]);
        mesh.position.set(x, y, z);
        mesh.castShadow = type !== 'water';
        mesh.receiveShadow = true;
        mesh.userData.blockType = type;
        scene.add(mesh);

        world.set(key, { type, mesh });
        if (type !== 'water') collidableMeshes.push(mesh);
      }

      function removeBlock(x, y, z) {
        const key = getBlockKey(x, y, z);
        const block = world.get(key);
        if (!block || block.type === 'water') return;
        scene.remove(block.mesh);
        const idx = collidableMeshes.indexOf(block.mesh);
        if (idx >= 0) collidableMeshes.splice(idx, 1);
        world.delete(key);
      }

      function groundHeight(x, z) {
        const n1 = Math.sin(x * 0.2) * Math.cos(z * 0.2);
        const n2 = Math.sin(x * 0.07 + 2.3) * Math.cos(z * 0.1 - 1.1);
        return Math.floor(6 + n1 * 2 + n2 * 3);
      }

      function generateWorld() {
        const isMobile = window.matchMedia('(max-width: 768px)').matches || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const size = isMobile ? 14 : 20;
        const waterLevel = 5;

        for (let x = -size; x <= size; x++) {
          for (let z = -size; z <= size; z++) {
            const topY = groundHeight(x, z);
            const isBeach = topY <= waterLevel + 1;
            for (let y = 0; y <= topY; y++) {
              if (y === topY) addBlock(x, y, z, isBeach ? 'sand' : 'grass');
              else if (y >= topY - 2) addBlock(x, y, z, isBeach ? 'sand' : 'dirt');
              else addBlock(x, y, z, 'stone');
            }
            if (topY < waterLevel) {
              for (let y = topY + 1; y <= waterLevel; y++) addBlock(x, y, z, 'water');
            }
          }
        }
      }

      generateWorld();

      const player = {
        position: new THREE.Vector3(0, 12, 8),
        velocity: new THREE.Vector3(),
        speed: 0.12,
        sprintSpeed: 0.2,
        jumpForce: 0.24,
        gravity: 0.015,
        height: 1.7,
        radius: 0.3,
        onGround: false,
        bob: 0
      };

      const keys = {};
      const look = { yaw: 0, pitch: 0, locked: false };
      const raycaster = new THREE.Raycaster();
      raycaster.far = 6;
      const upAxis = new THREE.Vector3(0, 1, 0);

      function solidAt(x, y, z) {
        const block = world.get(getBlockKey(Math.round(x), Math.floor(y), Math.round(z)));
        return !!block && block.type !== 'water';
      }

      function playerCollides(pos) {
        const yMin = pos.y;
        const yMax = pos.y + player.height;
        const points = [
          [pos.x - player.radius, pos.z - player.radius],
          [pos.x + player.radius, pos.z - player.radius],
          [pos.x - player.radius, pos.z + player.radius],
          [pos.x + player.radius, pos.z + player.radius]
        ];

        for (const [px, pz] of points) {
          for (let y = Math.floor(yMin); y <= Math.floor(yMax); y++) {
            if (solidAt(px, y, pz)) return true;
          }
        }
        return false;
      }

      function handleBlockAction(isBreak) {
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        const hits = raycaster.intersectObjects(collidableMeshes, false);
        if (!hits.length) return;

        const hit = hits[0];
        const target = hit.object.position;

        if (isBreak) {
          removeBlock(target.x, target.y, target.z);
          return;
        }

        const placePos = target.clone().add(hit.face.normal);
        addBlock(placePos.x, placePos.y, placePos.z, selectedBlock);
      }

      const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'cobblestone', 'planks'];
      let selectedBlock = 'grass';

      hotbar.innerHTML = '';
      blockTypes.forEach((name, idx) => {
        const slot = document.createElement('div');
        slot.className = 'block-slot' + (idx === 0 ? ' selected' : '');
        slot.style.background = `#${(blockMaterialByType[name].color ? blockMaterialByType[name].color.getHexString() : 'ffffff')}`;
        slot.innerHTML = `<div class="number">${idx + 1}</div>`;
        slot.addEventListener('click', () => {
          selectedBlock = name;
          [...hotbar.children].forEach((child, i) => {
            child.className = 'block-slot' + (i === idx ? ' selected' : '');
          });
        });
        hotbar.appendChild(slot);
      });

      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        const n = Number(e.key);
        if (n >= 1 && n <= blockTypes.length) {
          selectedBlock = blockTypes[n - 1];
          [...hotbar.children].forEach((child, i) => {
            child.className = 'block-slot' + (i === n - 1 ? ' selected' : '');
          });
        }
      });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      canvas.addEventListener('click', () => {
        if (!look.locked) canvas.requestPointerLock?.();
      });
      lookArea.addEventListener('touchend', () => { lookTouch.active = false; });

      document.addEventListener('pointerlockchange', () => {
        look.locked = document.pointerLockElement === canvas;
      });

      document.addEventListener('mousemove', (e) => {
        if (!look.locked) return;
        look.yaw += e.movementX * 0.002;
        look.pitch -= e.movementY * 0.002;
        look.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, look.pitch));
      });

      document.addEventListener('mousedown', (e) => {
        if (!look.locked) return;
        e.preventDefault();
        if (e.button === 0) handleBlockAction(true);
        if (e.button === 2) handleBlockAction(false);
      });

      document.addEventListener('contextmenu', (e) => e.preventDefault());

      function resize() {
        const width = canvas.clientWidth || window.innerWidth;
        const height = canvas.clientHeight || window.innerHeight;
        if (canvas.width !== width || canvas.height !== height) {
          renderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }
      }

      function update() {
        const speed = keys['ShiftLeft'] ? player.sprintSpeed : player.speed;
        const move = new THREE.Vector3();
        let moving = false;

        if (keys['KeyW']) { move.z -= speed; moving = true; }
        if (keys['KeyS']) { move.z += speed; moving = true; }
        if (keys['KeyA']) { move.x -= speed; moving = true; }
        if (keys['KeyD']) { move.x += speed; moving = true; }
        if (keys['Space'] && player.onGround) {
          player.velocity.y = player.jumpForce;
          player.onGround = false;
        }

        move.applyAxisAngle(upAxis, look.yaw);

        player.velocity.y -= player.gravity;

        const next = player.position.clone();
        next.x += move.x;
        next.z += move.z;

        const horizontalTry = player.position.clone();
        horizontalTry.x = next.x;
        if (!playerCollides(horizontalTry)) player.position.x = horizontalTry.x;
        horizontalTry.x = player.position.x;
        horizontalTry.z = next.z;
        if (!playerCollides(horizontalTry)) player.position.z = horizontalTry.z;

        const verticalTry = player.position.clone();
        verticalTry.y += player.velocity.y;
        if (!playerCollides(verticalTry)) {
          player.position.y = verticalTry.y;
          player.onGround = false;
        } else {
          if (player.velocity.y < 0) player.onGround = true;
          player.velocity.y = 0;
        }

        if (player.position.y < 1) {
          player.position.set(0, 12, 8);
          player.velocity.set(0, 0, 0);
        }

        if (moving && player.onGround) player.bob += 0.2;
        const bobAmount = moving && player.onGround ? Math.sin(player.bob) * 0.08 : 0;

        camera.position.copy(player.position);
        camera.position.y += player.height - 0.25 + bobAmount;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = look.yaw;
        camera.rotation.x = look.pitch;
      }

      function animate() {
        requestAnimationFrame(animate);
        resize();
        update();
        renderer.render(scene, camera);
        hideStatus();
      }

    function resizeRendererToDisplaySize() {
      const width = canvas.clientWidth || window.innerWidth;
      const height = canvas.clientHeight || window.innerHeight;
      if (canvas.width !== width || canvas.height !== height) {
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }

    function resize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let lastTime = performance.now();
    let frameCount = 0;
    let fpsTimer = 0;

    function animate(time) {
      requestAnimationFrame(animate);
      resizeRendererToDisplaySize();
      update();
      renderer.render(scene, camera);
      hideStatus();
    }

    // Resize
    window.addEventListener('resize', () => {
      resizeRendererToDisplaySize();
    });
  };

  startGame();
  </script>
</body>
</html>
