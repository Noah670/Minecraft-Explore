<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #87CEEB;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.85);
      color: #0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      border-radius: 5px;
      max-width: 200px;
      transition: all 0.3s;
      border: 1px solid rgba(0,255,0,0.3);
    }
    
    #status.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateX(-20px);
    }
    
    #close-status {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255,0,0,0.7);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      padding: 0;
      font-weight: bold;
    }
    
    #close-status:hover {
      background: rgba(255,50,50,1);
    }
    
    #toggle-status {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.85);
      color: #0f0;
      border: 1px solid rgba(0,255,0,0.5);
      padding: 6px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      z-index: 1001;
      display: none;
      transition: all 0.2s;
    }
    
    #toggle-status:hover {
      background: rgba(0,100,0,0.9);
      border-color: rgba(0,255,0,0.8);
    }
    
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      z-index: 100;
    }
    
    #crosshair::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 20px;
      background: white;
      left: 8px;
      box-shadow: 0 0 3px black;
    }
    
    #crosshair::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 3px;
      background: white;
      top: 8px;
      box-shadow: 0 0 3px black;
    }
    
    #ui {
      position: fixed;
      top: 50px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.85);
      padding: 12px 15px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 100;
      max-width: 200px;
      border: 1px solid rgba(255,255,255,0.2);
      transition: all 0.3s;
    }
    
    #ui.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateX(-20px);
    }
    
    #ui h3 {
      margin-bottom: 8px;
      font-size: 15px;
    }
    
    #ui div {
      margin: 4px 0;
      font-size: 12px;
    }
    
    #close-ui {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      padding: 0;
      font-weight: bold;
    }
    
    #close-ui:hover {
      background: rgba(255,255,255,0.4);
    }
    
    #hotbar {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      padding: 10px;
      background: rgba(0,0,0,0.8);
      border-radius: 10px;
      z-index: 100;
    }
    
    .block-slot {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .block-slot.selected {
      border-color: white;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    
    .block-slot .num {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0,0,0,0.6);
      padding: 2px 5px;
      border-radius: 3px;
    }
    
    /* Mobile Controls */
    #mobile-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
    }
    
    #joystick {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(255,255,255,0.15);
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      pointer-events: auto;
      backdrop-filter: blur(5px);
    }
    
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.5);
      border: 3px solid rgba(255,255,255,0.7);
      border-radius: 50%;
      transition: transform 0.1s ease-out;
    }
    
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 14px;
      border: 4px solid rgba(255,255,255,0.3);
      backdrop-filter: blur(10px);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #jumpBtn {
      bottom: 110px;
      right: 30px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80,220,80,0.7), rgba(40,180,40,0.7));
    }
    
    #placeBtn {
      bottom: 30px;
      right: 140px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(80,180,255,0.7), rgba(40,140,220,0.7));
    }
    
    #breakBtn {
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(255,80,80,0.7), rgba(220,40,40,0.7));
    }
    
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 60%;
      height: 70%;
      pointer-events: auto;
      touch-action: none;
    }
    
    @media (max-width: 768px), (pointer: coarse) {
      #hotbar {
        bottom: 160px;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="status">
    <button id="close-status">√ó</button>
    <div>Status: <span id="status-text">Initializing...</span></div>
    <div>Renderer: <span id="renderer-status">Not started</span></div>
    <div>World: <span id="world-status">Not generated</span></div>
    <div>Player: <span id="player-pos">X:0 Y:0 Z:0</span></div>
    <div>On Ground: <span id="on-ground">No</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
  
  <button id="toggle-status">Show Debug</button>
  
  <div id="crosshair"></div>
  
  <div id="ui">
    <button id="close-ui">√ó</button>
    <h3>‚õèÔ∏è Controls</h3>
    <div>üéÆ WASD - Move</div>
    <div>‚¨ÜÔ∏è Space - Jump</div>
    <div>üñ±Ô∏è Mouse - Look</div>
    <div>üî® Left Click - Break</div>
    <div>üì¶ Right Click - Place</div>
    <div>üî¢ 1-5 - Select Block</div>
    <div style="margin-top:10px; font-size:11px; opacity:0.8;">Click screen to play</div>
  </div>
  
  <div id="hotbar"></div>
  
  <!-- Mobile Controls -->
  <div id="mobile-controls" style="display: none;">
    <div id="joystick">
      <div id="joystick-knob"></div>
    </div>
    <button id="jumpBtn" class="mobile-btn">JUMP</button>
    <button id="placeBtn" class="mobile-btn">PLACE</button>
    <button id="breakBtn" class="mobile-btn">BREAK</button>
    <div id="lookArea"></div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    
    // Debug logging
    function log(message, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${message}`);
      document.getElementById('status-text').textContent = message;
    }
    
    log('Starting initialization...');
    
    // Scene setup
    let scene, camera, renderer, world, player;
    let selectedBlock = 'grass';
    let keys = {};
    let mouse = { x: 0, y: 0, locked: false };
    
    // Mobile controls
    const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    const joystick = { active: false, deltaX: 0, deltaY: 0 };
    const lookTouch = { active: false, lastX: 0, lastY: 0 };
    
    // Initialize Three.js
    function initThree() {
      log('Creating scene...');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 40, 100);
      
      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 15, 5);
      
      // Renderer
      const container = document.getElementById('canvas-container');
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: false
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      
      container.appendChild(renderer.domElement);
      
      log('Renderer created', 'success');
      document.getElementById('renderer-status').textContent = 'Active';
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xfff9e6, 1.0);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);
      
      // Add subtle fill light
      const fillLight = new THREE.DirectionalLight(0x8ec5fc, 0.3);
      fillLight.position.set(-30, 20, -30);
      scene.add(fillLight);
      
      log('Lighting setup complete');
      
      return true;
    }
    
    // Block materials with improved colors
    const materials = {
      grass: new THREE.MeshLambertMaterial({ 
        color: 0x7ac74f,
        flatShading: true 
      }),
      dirt: new THREE.MeshLambertMaterial({ 
        color: 0x8b6914,
        flatShading: true 
      }),
      stone: new THREE.MeshLambertMaterial({ 
        color: 0x888888,
        flatShading: true 
      }),
      wood: new THREE.MeshLambertMaterial({ 
        color: 0x8b5a2b,
        flatShading: true 
      }),
      sand: new THREE.MeshLambertMaterial({ 
        color: 0xf4d999,
        flatShading: true 
      })
    };
    
    const sharedGeometry = new THREE.BoxGeometry(1, 1, 1);

    // World generation
    function initWorld() {
      log('Generating world...');
      world = new Map();
      
      const size = 15;
      let blocksCreated = 0;
      
      // Create a solid bedrock layer first
      for (let x = -size; x <= size; x++) {
        for (let z = -size; z <= size; z++) {
          addBlock(x, 0, z, 'stone');
          blocksCreated++;
        }
      }
      
      // Add terrain on top with height variation
      for (let x = -size; x <= size; x++) {
        for (let z = -size; z <= size; z++) {
          // Create smooth hills using simple noise
          const height = Math.floor(
            Math.sin(x * 0.2) * Math.cos(z * 0.2) * 2 +
            Math.sin(x * 0.5) * Math.cos(z * 0.5) * 1
          ) + 4;
          
          for (let y = 1; y <= height; y++) {
            let blockType = 'stone';
            
            if (y === height) {
              blockType = 'grass';
            } else if (y === height - 1) {
              blockType = 'dirt';
            } else if (y === height - 2) {
              blockType = 'dirt';
            }
            
            addBlock(x, y, z, blockType);
            blocksCreated++;
          }
        }
      }
      
      log(`World generated: ${blocksCreated} blocks`, 'success');
      document.getElementById('world-status').textContent = `${blocksCreated} blocks`;
      
      return true;
    }
    
    function getKey(x, y, z) {
      return `${x},${y},${z}`;
    }
    
    function addBlock(x, y, z, type) {
      const key = getKey(x, y, z);
      if (world.has(key)) return;
      
      const material = materials[type] || materials.stone;
      const mesh = new THREE.Mesh(sharedGeometry, material);
      
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      scene.add(mesh);
      world.set(key, { mesh, type });
    }
    
    function removeBlock(x, y, z) {
      const key = getKey(x, y, z);
      const block = world.get(key);
      
      if (block) {
        scene.remove(block.mesh);
        world.delete(key);
      }
    }
    
    // Player setup
    function initPlayer() {
      player = {
        position: new THREE.Vector3(0, 10, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        height: 1.7,
        radius: 0.4,
        speed: 0.15,
        jumpForce: 0.2,
        gravity: 0.02,
        onGround: false,
        bobPhase: 0,
        bobSpeed: 0.18,
        bobAmount: 0.08
      };
      
      log('Player initialized');
    }
    
    // Input handling
    function initInput() {
      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        
        // Block selection
        const num = parseInt(e.key);
        if (num >= 1 && num <= 5) {
          const types = ['grass', 'dirt', 'stone', 'wood', 'sand'];
          selectedBlock = types[num - 1];
          updateHotbar();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!mouse.locked) return;
        mouse.x += e.movementX * 0.002;
        mouse.y += e.movementY * 0.002;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
      });
      
      renderer.domElement.addEventListener('click', () => {
        renderer.domElement.requestPointerLock();
      });
      
      document.addEventListener('pointerlockchange', () => {
        mouse.locked = document.pointerLockElement === renderer.domElement;
      });
      
      document.addEventListener('mousedown', (e) => {
        if (!mouse.locked) return;
        e.preventDefault();
        
        if (e.button === 0) {
          performBlockAction(true);
        } else if (e.button === 2) {
          performBlockAction(false);
        }
      });
      
      document.addEventListener('contextmenu', (e) => e.preventDefault());
      
      log('Input handlers initialized');
    }
    
    // Mobile controls setup
    function initMobileControls() {
      if (!isMobile) return;
      
      document.getElementById('mobile-controls').style.display = 'block';
      
      const joystickEl = document.getElementById('joystick');
      const knob = document.getElementById('joystick-knob');
      
      joystickEl.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystick.active = true;
      });
      
      joystickEl.addEventListener('touchmove', (e) => {
        if (!joystick.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const rect = joystickEl.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const deltaX = touch.clientX - centerX;
        const deltaY = touch.clientY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDist = 50;
        
        if (distance > maxDist) {
          const angle = Math.atan2(deltaY, deltaX);
          joystick.deltaX = Math.cos(angle);
          joystick.deltaY = Math.sin(angle);
        } else {
          joystick.deltaX = deltaX / maxDist;
          joystick.deltaY = deltaY / maxDist;
        }
        
        knob.style.transform = `translate(-50%, -50%) translate(${joystick.deltaX * 50}px, ${joystick.deltaY * 50}px)`;
      });
      
      joystickEl.addEventListener('touchend', () => {
        joystick.active = false;
        joystick.deltaX = 0;
        joystick.deltaY = 0;
        knob.style.transform = 'translate(-50%, -50%)';
      });
      
      // Look controls
      const lookArea = document.getElementById('lookArea');
      lookArea.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        lookTouch.active = true;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
      });
      
      lookArea.addEventListener('touchmove', (e) => {
        if (!lookTouch.active) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const deltaX = (touch.clientX - lookTouch.lastX) * 0.004;
        const deltaY = (touch.clientY - lookTouch.lastY) * 0.004;
        
        mouse.x += deltaX;
        mouse.y += deltaY;
        mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
        
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
      });
      
      lookArea.addEventListener('touchend', () => {
        lookTouch.active = false;
      });
      
      document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (player.onGround) {
          player.velocity.y = player.jumpForce;
          player.onGround = false;
        }
      });
      
      document.getElementById('placeBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        performBlockAction(false);
      });
      
      document.getElementById('breakBtn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        performBlockAction(true);
      });
      
      log('Mobile controls initialized');
    }
    
    function performBlockAction(isBreak) {
      const raycaster = new THREE.Raycaster();
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);
      raycaster.set(camera.position, direction);
      raycaster.far = 6;
      
      const intersects = [];
      world.forEach(({ mesh }) => {
        const hit = raycaster.intersectObject(mesh);
        if (hit.length > 0) {
          intersects.push({ ...hit[0], mesh });
        }
      });
      
      intersects.sort((a, b) => a.distance - b.distance);
      
      if (intersects.length > 0) {
        const { face, mesh } = intersects[0];
        const pos = mesh.position;
        
        if (isBreak) {
          removeBlock(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z));
        } else {
          const normal = face.normal;
          const newPos = new THREE.Vector3(
            Math.round(pos.x + normal.x),
            Math.round(pos.y + normal.y),
            Math.round(pos.z + normal.z)
          );
          
          const playerBox = new THREE.Box3(
            new THREE.Vector3(
              player.position.x - player.radius,
              player.position.y,
              player.position.z - player.radius
            ),
            new THREE.Vector3(
              player.position.x + player.radius,
              player.position.y + player.height,
              player.position.z + player.radius
            )
          );
          
          const newBlockBox = new THREE.Box3(
            new THREE.Vector3(newPos.x - 0.5, newPos.y - 0.5, newPos.z - 0.5),
            new THREE.Vector3(newPos.x + 0.5, newPos.y + 0.5, newPos.z + 0.5)
          );
          
          if (!playerBox.intersectsBox(newBlockBox)) {
            addBlock(newPos.x, newPos.y, newPos.z, selectedBlock);
          }
        }
      }
    }
    
    function checkCollision(pos) {
      const box = new THREE.Box3(
        new THREE.Vector3(
          pos.x - player.radius,
          pos.y,
          pos.z - player.radius
        ),
        new THREE.Vector3(
          pos.x + player.radius,
          pos.y + player.height,
          pos.z + player.radius
        )
      );
      
      for (const { mesh } of world.values()) {
        const blockBox = new THREE.Box3().setFromObject(mesh);
        if (box.intersectsBox(blockBox)) {
          return true;
        }
      }
      return false;
    }
    
    function isOnGround() {
      const feetPos = player.position.clone();
      feetPos.y -= 0.1;
      
      for (const { mesh } of world.values()) {
        const blockBox = new THREE.Box3().setFromObject(mesh);
        const feetBox = new THREE.Box3(
          new THREE.Vector3(
            feetPos.x - player.radius,
            feetPos.y,
            feetPos.z - player.radius
          ),
          new THREE.Vector3(
            feetPos.x + player.radius,
            feetPos.y + 0.1,
            feetPos.z + player.radius
          )
        );
        
        if (feetBox.intersectsBox(blockBox)) {
          return true;
        }
      }
      return false;
    }
    
    function updatePlayer() {
      if (!player.onGround) {
        player.velocity.y -= player.gravity;
      }
      
      const moveDir = new THREE.Vector3();
      let isMoving = false;
      
      if (isMobile) {
        if (Math.abs(joystick.deltaX) > 0.1 || Math.abs(joystick.deltaY) > 0.1) {
          moveDir.x = joystick.deltaX;
          moveDir.z = joystick.deltaY;
          isMoving = true;
        }
      } else {
        if (keys['KeyW']) {
          moveDir.z -= 1;
          isMoving = true;
        }
        if (keys['KeyS']) {
          moveDir.z += 1;
          isMoving = true;
        }
        if (keys['KeyA']) {
          moveDir.x -= 1;
          isMoving = true;
        }
        if (keys['KeyD']) {
          moveDir.x += 1;
          isMoving = true;
        }
      }
      
      if (isMoving) {
        moveDir.normalize();
        moveDir.multiplyScalar(player.speed);
      }
      
      moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouse.x);
      
      const newPosX = player.position.clone();
      newPosX.x += moveDir.x;
      
      if (!checkCollision(newPosX)) {
        player.position.x = newPosX.x;
      }
      
      const newPosZ = player.position.clone();
      newPosZ.z += moveDir.z;
      
      if (!checkCollision(newPosZ)) {
        player.position.z = newPosZ.z;
      }
      
      player.onGround = isOnGround();
      
      if (keys['Space'] && player.onGround) {
        player.velocity.y = player.jumpForce;
        player.onGround = false;
      }
      
      const newPosY = player.position.clone();
      newPosY.y += player.velocity.y;
      
      if (!checkCollision(newPosY)) {
        player.position.y = newPosY.y;
      } else {
        if (player.velocity.y < 0) {
          player.velocity.y = 0;
          player.onGround = true;
        } else {
          player.velocity.y = 0;
        }
      }
      
      if (player.position.y < 1) {
        player.position.y = 10;
        player.velocity.y = 0;
      }
      
      let bobOffset = 0;
      if (isMoving && player.onGround) {
        player.bobPhase += player.bobSpeed;
        bobOffset = Math.sin(player.bobPhase) * player.bobAmount;
      } else {
        player.bobPhase = 0;
      }
      
      camera.position.copy(player.position);
      camera.position.y += player.height - 0.3 + bobOffset;
      
      camera.rotation.order = 'YXZ';
      camera.rotation.y = mouse.x;
      camera.rotation.x = mouse.y;
    }
    
    function initHotbar() {
      const hotbar = document.getElementById('hotbar');
      const blocks = [
        { name: 'grass', color: '#7ac74f' },
        { name: 'dirt', color: '#8b6914' },
        { name: 'stone', color: '#888888' },
        { name: 'wood', color: '#8b5a2b' },
        { name: 'sand', color: '#f4d999' }
      ];
      
      blocks.forEach((block, i) => {
        const slot = document.createElement('div');
        slot.className = 'block-slot';
        if (block.name === selectedBlock) slot.classList.add('selected');
        slot.style.background = block.color;
        slot.innerHTML = `<div class="num">${i + 1}</div>`;
        slot.onclick = () => {
          selectedBlock = block.name;
          updateHotbar();
        };
        hotbar.appendChild(slot);
      });
    }
    
    function updateHotbar() {
      const slots = document.querySelectorAll('.block-slot');
      const blocks = ['grass', 'dirt', 'stone', 'wood', 'sand'];
      slots.forEach((slot, i) => {
        if (blocks[i] === selectedBlock) {
          slot.classList.add('selected');
        } else {
          slot.classList.remove('selected');
        }
      });
    }
    
    let lastTime = performance.now();
    let frameCount = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      updatePlayer();
      renderer.render(scene, camera);
      
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        document.getElementById('fps').textContent = frameCount;
        document.getElementById('player-pos').textContent = 
          `X:${player.position.x.toFixed(1)} Y:${player.position.y.toFixed(1)} Z:${player.position.z.toFixed(1)}`;
        document.getElementById('on-ground').textContent = player.onGround ? 'Yes' : 'No';
        frameCount = 0;
        lastTime = now;
      }
    }
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    async function bootstrap() {
      try {
        log('Bootstrap starting...');
        
        if (!initThree()) {
          throw new Error('Failed to initialize Three.js');
        }
        
        if (!initWorld()) {
          throw new Error('Failed to generate world');
        }
        
        initPlayer();
        initInput();
        initMobileControls();
        initHotbar();
        
        log('Starting render loop...', 'success');
        animate();
        
        log('Game ready!', 'success');
        
        const statusEl = document.getElementById('status');
        const toggleBtn = document.getElementById('toggle-status');
        const uiEl = document.getElementById('ui');
        
        document.getElementById('close-status').addEventListener('click', () => {
          statusEl.classList.add('hidden');
          toggleBtn.style.display = 'block';
        });
        
        toggleBtn.addEventListener('click', () => {
          statusEl.classList.remove('hidden');
          toggleBtn.style.display = 'none';
        });
        
        document.getElementById('close-ui').addEventListener('click', () => {
          uiEl.classList.add('hidden');
        });
        
        if (isMobile) {
          setTimeout(() => {
            uiEl.classList.add('hidden');
            statusEl.classList.add('hidden');
            toggleBtn.style.display = 'block';
          }, 5000);
        }
        
        setTimeout(() => {
          renderer.render(scene, camera);
          log('First render complete', 'success');
        }, 100);
        
      } catch (error) {
        log(`ERROR: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    bootstrap();
  </script>
</body>
</html>
