<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      background: #000;
    }
    
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 100;
    }
    
    #crosshair::before {
      content: '';
      position: absolute;
      width: 4px;
      height: 24px;
      background: white;
      left: -2px;
      top: -12px;
      box-shadow: 0 0 4px black;
    }
    
    #crosshair::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 4px;
      background: white;
      left: -12px;
      top: -2px;
      box-shadow: 0 0 4px black;
    }
    
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0,0,0,0.85);
      padding: 18px 22px;
      border-radius: 12px;
      font-size: 15px;
      line-height: 1.7;
      z-index: 100;
      border: 2px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
    }
    
    #ui h2 {
      font-size: 20px;
      margin-bottom: 12px;
    }
    
    #ui .hint {
      margin-top: 14px;
      font-size: 13px;
      opacity: 0.85;
      font-style: italic;
    }

    #status {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 18px 26px;
      border-radius: 12px;
      font-size: 16px;
      text-align: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
      max-width: 320px;
    }

    #status.hidden {
      display: none;
    }
    
    #hotbar {
      position: fixed;
      bottom: 45px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 14px;
      background: rgba(0,0,0,0.85);
      border-radius: 14px;
      border: 3px solid rgba(255,255,255,0.25);
      backdrop-filter: blur(10px);
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    
    .block-slot {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      cursor: pointer;
      position: relative;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
      transition: all 0.2s;
      border: 4px solid rgba(255,255,255,0.25);
    }
    
    .block-slot.selected {
      border: 4px solid white;
      box-shadow: 0 0 20px rgba(255,255,255,0.8), inset 0 2px 8px rgba(255,255,255,0.4);
      transform: scale(1.15) translateY(-4px);
    }
    
    .block-slot .number {
      position: absolute;
      top: -26px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: bold;
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 4px 8px;
      border-radius: 6px;
      white-space: nowrap;
      text-shadow: 0 2px 4px black;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    /* Mobile controls */
    .mobile-controls {
      display: none;
    }
    
    @media (max-width: 768px), (pointer: coarse) {
      #ui {
        font-size: 14px;
        padding: 14px 18px;
        right: 20px;
      }
      
      #hotbar {
        bottom: 150px;
      }
      
      .mobile-controls {
        display: block;
      }
    }
    
    #joystick {
      position: fixed;
      bottom: 35px;
      left: 35px;
      width: 150px;
      height: 150px;
      background: rgba(255,255,255,0.12);
      border: 5px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 65px;
      height: 65px;
      background: rgba(255,255,255,0.5);
      border: 4px solid rgba(255,255,255,0.8);
      border-radius: 50%;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      transition: transform 0.1s ease-out;
    }
    
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #jumpBtn {
      bottom: 120px;
      right: 35px;
      width: 100px;
      height: 100px;
      background: linear-gradient(145deg, rgba(80,220,80,0.7), rgba(40,180,40,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 17px;
    }
    
    #placeBtn {
      bottom: 35px;
      right: 155px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80,180,255,0.7), rgba(40,140,220,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 15px;
    }
    
    #breakBtn {
      bottom: 35px;
      right: 35px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(255,80,80,0.7), rgba(220,40,40,0.7));
      border: 5px solid rgba(255,255,255,0.3);
      font-size: 15px;
    }
    
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 65%;
      height: 75%;
      z-index: 99;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div id="crosshair"></div>
  
  <div id="ui">
    <h2>‚õèÔ∏è Minecraft Clone</h2>
    <div>üéÆ <strong>WASD</strong> - Move</div>
    <div>üèÉ <strong>Shift</strong> - Sprint</div>
    <div>‚¨ÜÔ∏è <strong>Space</strong> - Jump</div>
    <div>üñ±Ô∏è <strong>Mouse</strong> - Look</div>
    <div>‚ùå <strong>Left Click</strong> - Break</div>
    <div>‚úÖ <strong>Right Click</strong> - Place</div>
    <div>üî¢ <strong>1-8</strong> - Select Block</div>
    <div class="hint">üí° Click to lock cursor</div>
  </div>
  
  <div id="hotbar"></div>

  <div id="status">Loading world...</div>
  
  <div class="mobile-controls">
    <div id="joystick">
      <div id="joystick-knob"></div>
    </div>
    <div id="jumpBtn" class="mobile-btn">JUMP</div>
    <div id="placeBtn" class="mobile-btn">PLACE</div>
    <div id="breakBtn" class="mobile-btn">BREAK</div>
    <div id="lookArea"></div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('gameCanvas');
    const hotbar = document.getElementById('hotbar');

    const showStatus = (message) => {
      statusEl.textContent = message;
      statusEl.classList.remove('hidden');
    };

    const hideStatus = () => statusEl.classList.add('hidden');

    const reportError = (message, error) => {
      const detail = error && error.message ? `
${error.message}` : '';
      showStatus(`${message}${detail}`);
      console.error(message, error);
    };

    const scriptSources = [
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
      'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
      'https://unpkg.com/three@0.128.0/build/three.min.js'
    ];

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(script);
      });
    }

    async function loadThree() {
      for (const src of scriptSources) {
        try {
          await loadScript(src);
          if (window.THREE) return window.THREE;
        } catch (error) {
          console.warn(error);
        }
      }
      throw new Error('Unable to load Three.js from all configured CDNs.');
    }

    function isWebGLAvailable() {
      try {
        const testCanvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (
          testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl')
        ));
      } catch (error) {
        return false;
      }
    }

    function getBlockKey(x, y, z) {
      return `${x}|${y}|${z}`;
    }

    function createGame(THREE) {
      if (!isWebGLAvailable()) {
        showStatus('WebGL is unavailable. Enable hardware acceleration or use a modern browser.');
        return;
      }

      showStatus('Building world...');

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 35, 120);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setClearColor(0x87CEEB, 1);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);

      canvas.addEventListener('webglcontextlost', (event) => {
        event.preventDefault();
        showStatus('WebGL context lost. Refresh to restore rendering.');
      });

      scene.add(new THREE.AmbientLight(0xffffff, 0.65));
      const sun = new THREE.DirectionalLight(0xfff9e6, 0.9);
      sun.position.set(60, 90, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024, 1024);
      scene.add(sun);

      const world = new Map();
      const collidableMeshes = [];
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
      const materials = {
        grassTop: new THREE.MeshLambertMaterial({ color: 0x5cb230 }),
        grassSide: new THREE.MeshLambertMaterial({ color: 0x4a7a2f }),
        dirt: new THREE.MeshLambertMaterial({ color: 0x7d5f35 }),
        stone: new THREE.MeshLambertMaterial({ color: 0x7a7a7a }),
        wood: new THREE.MeshLambertMaterial({ color: 0x6b4423 }),
        leaves: new THREE.MeshLambertMaterial({ color: 0x2d8b2d, transparent: true, opacity: 0.9 }),
        sand: new THREE.MeshLambertMaterial({ color: 0xe8c998 }),
        cobblestone: new THREE.MeshLambertMaterial({ color: 0x5a5a5a }),
        planks: new THREE.MeshLambertMaterial({ color: 0xb8935f }),
        water: new THREE.MeshLambertMaterial({ color: 0x3d8fd1, transparent: true, opacity: 0.75 })
      };

      const blockMaterialByType = {
        grass: [materials.grassSide, materials.grassSide, materials.grassTop, materials.dirt, materials.grassSide, materials.grassSide],
        dirt: materials.dirt,
        stone: materials.stone,
        wood: materials.wood,
        leaves: materials.leaves,
        sand: materials.sand,
        cobblestone: materials.cobblestone,
        planks: materials.planks,
        water: materials.water
      };

      function addBlock(x, y, z, type) {
        const key = getBlockKey(x, y, z);
        if (world.has(key)) return;

        const mesh = new THREE.Mesh(blockGeometry, blockMaterialByType[type]);
        mesh.position.set(x, y, z);
        mesh.castShadow = type !== 'water';
        mesh.receiveShadow = true;
        mesh.userData.blockType = type;
        scene.add(mesh);

        world.set(key, { type, mesh });
        if (type !== 'water') collidableMeshes.push(mesh);
      }

      function removeBlock(x, y, z) {
        const key = getBlockKey(x, y, z);
        const block = world.get(key);
        if (!block || block.type === 'water') return;
        scene.remove(block.mesh);
        const idx = collidableMeshes.indexOf(block.mesh);
        if (idx >= 0) collidableMeshes.splice(idx, 1);
        world.delete(key);
      }

      function groundHeight(x, z) {
        const n1 = Math.sin(x * 0.2) * Math.cos(z * 0.2);
        const n2 = Math.sin(x * 0.07 + 2.3) * Math.cos(z * 0.1 - 1.1);
        return Math.floor(6 + n1 * 2 + n2 * 3);
      }

      function generateWorld() {
        const isMobile = window.matchMedia('(max-width: 768px)').matches || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const size = isMobile ? 14 : 20;
        const waterLevel = 5;

        for (let x = -size; x <= size; x++) {
          for (let z = -size; z <= size; z++) {
            const topY = groundHeight(x, z);
            const isBeach = topY <= waterLevel + 1;
            for (let y = 0; y <= topY; y++) {
              if (y === topY) addBlock(x, y, z, isBeach ? 'sand' : 'grass');
              else if (y >= topY - 2) addBlock(x, y, z, isBeach ? 'sand' : 'dirt');
              else addBlock(x, y, z, 'stone');
            }
            if (topY < waterLevel) {
              for (let y = topY + 1; y <= waterLevel; y++) addBlock(x, y, z, 'water');
            }
          }
        }
      }

      generateWorld();

      const player = {
        position: new THREE.Vector3(0, 12, 8),
        velocity: new THREE.Vector3(),
        speed: 0.12,
        sprintSpeed: 0.2,
        jumpForce: 0.24,
        gravity: 0.015,
        height: 1.7,
        radius: 0.3,
        onGround: false,
        bob: 0
      };

      const keys = {};
      const look = { yaw: 0, pitch: 0, locked: false };
      const raycaster = new THREE.Raycaster();
      raycaster.far = 6;
      const upAxis = new THREE.Vector3(0, 1, 0);

      function solidAt(x, y, z) {
        const block = world.get(getBlockKey(Math.round(x), Math.floor(y), Math.round(z)));
        return !!block && block.type !== 'water';
      }

      function playerCollides(pos) {
        const yMin = pos.y;
        const yMax = pos.y + player.height;
        const points = [
          [pos.x - player.radius, pos.z - player.radius],
          [pos.x + player.radius, pos.z - player.radius],
          [pos.x - player.radius, pos.z + player.radius],
          [pos.x + player.radius, pos.z + player.radius]
        ];

        for (const [px, pz] of points) {
          for (let y = Math.floor(yMin); y <= Math.floor(yMax); y++) {
            if (solidAt(px, y, pz)) return true;
          }
        }
        return false;
      }

      function handleBlockAction(isBreak) {
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        const hits = raycaster.intersectObjects(collidableMeshes, false);
        if (!hits.length) return;

        const hit = hits[0];
        const target = hit.object.position;

        if (isBreak) {
          removeBlock(target.x, target.y, target.z);
          return;
        }

        const placePos = target.clone().add(hit.face.normal);
        addBlock(placePos.x, placePos.y, placePos.z, selectedBlock);
      }

      const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'cobblestone', 'planks'];
      let selectedBlock = 'grass';

      hotbar.innerHTML = '';
      blockTypes.forEach((name, idx) => {
        const slot = document.createElement('div');
        slot.className = 'block-slot' + (idx === 0 ? ' selected' : '');
        slot.style.background = `#${(blockMaterialByType[name].color ? blockMaterialByType[name].color.getHexString() : 'ffffff')}`;
        slot.innerHTML = `<div class="number">${idx + 1}</div>`;
        slot.addEventListener('click', () => {
          selectedBlock = name;
          [...hotbar.children].forEach((child, i) => {
            child.className = 'block-slot' + (i === idx ? ' selected' : '');
          });
        });
        hotbar.appendChild(slot);
      });

      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        const n = Number(e.key);
        if (n >= 1 && n <= blockTypes.length) {
          selectedBlock = blockTypes[n - 1];
          [...hotbar.children].forEach((child, i) => {
            child.className = 'block-slot' + (i === n - 1 ? ' selected' : '');
          });
        }
      });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      canvas.addEventListener('click', () => {
        if (!look.locked) canvas.requestPointerLock?.();
      });

      document.addEventListener('pointerlockchange', () => {
        look.locked = document.pointerLockElement === canvas;
      });

      document.addEventListener('mousemove', (e) => {
        if (!look.locked) return;
        look.yaw += e.movementX * 0.002;
        look.pitch -= e.movementY * 0.002;
        look.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, look.pitch));
      });

      document.addEventListener('mousedown', (e) => {
        if (!look.locked) return;
        e.preventDefault();
        if (e.button === 0) handleBlockAction(true);
        if (e.button === 2) handleBlockAction(false);
      });

      document.addEventListener('contextmenu', (e) => e.preventDefault());

      function resize() {
        const width = canvas.clientWidth || window.innerWidth;
        const height = canvas.clientHeight || window.innerHeight;
        if (canvas.width !== width || canvas.height !== height) {
          renderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }
      }

      function update() {
        const speed = keys['ShiftLeft'] ? player.sprintSpeed : player.speed;
        const move = new THREE.Vector3();
        let moving = false;

        if (keys['KeyW']) { move.z -= speed; moving = true; }
        if (keys['KeyS']) { move.z += speed; moving = true; }
        if (keys['KeyA']) { move.x -= speed; moving = true; }
        if (keys['KeyD']) { move.x += speed; moving = true; }
        if (keys['Space'] && player.onGround) {
          player.velocity.y = player.jumpForce;
          player.onGround = false;
        }

        move.applyAxisAngle(upAxis, look.yaw);

        player.velocity.y -= player.gravity;

        const next = player.position.clone();
        next.x += move.x;
        next.z += move.z;

        const horizontalTry = player.position.clone();
        horizontalTry.x = next.x;
        if (!playerCollides(horizontalTry)) player.position.x = horizontalTry.x;
        horizontalTry.x = player.position.x;
        horizontalTry.z = next.z;
        if (!playerCollides(horizontalTry)) player.position.z = horizontalTry.z;

        const verticalTry = player.position.clone();
        verticalTry.y += player.velocity.y;
        if (!playerCollides(verticalTry)) {
          player.position.y = verticalTry.y;
          player.onGround = false;
        } else {
          if (player.velocity.y < 0) player.onGround = true;
          player.velocity.y = 0;
        }

        if (player.position.y < 1) {
          player.position.set(0, 12, 8);
          player.velocity.set(0, 0, 0);
        }

        if (moving && player.onGround) player.bob += 0.2;
        const bobAmount = moving && player.onGround ? Math.sin(player.bob) * 0.08 : 0;

        camera.position.copy(player.position);
        camera.position.y += player.height - 0.25 + bobAmount;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = look.yaw;
        camera.rotation.x = look.pitch;
      }

      function animate() {
        requestAnimationFrame(animate);
        resize();
        update();
        renderer.render(scene, camera);
        hideStatus();
      }

      window.addEventListener('resize', resize);
      animate();
    }

    window.addEventListener('error', (event) => {
      reportError('An error occurred while loading the world.', event.error || event.message);
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError('A loading error occurred.', event.reason);
    });

    (async () => {
      showStatus('Loading Three.js...');
      try {
        const THREE = await loadThree();
        createGame(THREE);
      } catch (error) {
        reportError('Failed to start the 3D world.', error);
      }
    })();
  </script>
</body>
</html>
