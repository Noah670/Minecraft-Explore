<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Minecraft Clone - 3D Voxel Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: Arial, sans-serif; background: #87CEEB; }

    canvas#gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }

    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 18px 26px;
      border-radius: 12px;
      font-size: 16px;
      text-align: center;
      z-index: 200;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4);
      max-width: 320px;
    }
    #loading.hidden { display: none; }

    #debug-panel {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      border-radius: 5px;
      max-width: 220px;
      border: 1px solid rgba(0, 255, 0, 0.3);
      transition: all 0.3s;
    }
    #debug-panel.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

    #close-debug {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 0, 0, 0.7);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: bold;
      line-height: 1;
      padding: 0;
    }
    #close-debug:hover { background: rgba(255, 50, 50, 1); }

    #toggle-debug {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      border: 1px solid rgba(0, 255, 0, 0.5);
      padding: 6px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-family: monospace;
      font-size: 11px;
      z-index: 1001;
      display: none;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      z-index: 100;
    }
    #crosshair::before {
      content: '';
      position: absolute;
      width: 3px;
      height: 20px;
      background: white;
      left: 8px;
      box-shadow: 0 0 3px black;
    }
    #crosshair::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 3px;
      background: white;
      top: 8px;
      box-shadow: 0 0 3px black;
    }

    #ui {
      position: fixed;
      top: 50px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.85);
      padding: 12px 15px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 100;
      max-width: 220px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s;
    }
    #ui.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }
    #ui h3 { margin-bottom: 8px; font-size: 15px; }
    #ui div { margin: 4px 0; font-size: 12px; }

    #close-ui {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      line-height: 1;
      padding: 0;
      font-weight: bold;
    }

    #hotbar {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 5px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      z-index: 100;
    }

    .block-slot {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .block-slot.selected {
      border-color: white;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .block-slot .num {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 11px;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.6);
      padding: 2px 5px;
      border-radius: 3px;
    }

    #mobile-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 90;
      display: none;
    }
    #joystick {
      position: fixed;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(255, 255, 255, 0.15);
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
      backdrop-filter: blur(5px);
    }
    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.5);
      border: 3px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      transition: transform 0.1s ease-out;
    }
    .mobile-btn {
      position: fixed;
      border-radius: 50%;
      color: white;
      font-weight: bold;
      font-size: 14px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #jumpBtn {
      bottom: 110px;
      right: 30px;
      width: 90px;
      height: 90px;
      background: linear-gradient(145deg, rgba(80, 220, 80, 0.7), rgba(40, 180, 40, 0.7));
    }
    #placeBtn {
      bottom: 30px;
      right: 140px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(80, 180, 255, 0.7), rgba(40, 140, 220, 0.7));
    }
    #breakBtn {
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, rgba(255, 80, 80, 0.7), rgba(220, 40, 40, 0.7));
    }
    #lookArea {
      position: fixed;
      top: 0;
      right: 0;
      width: 60%;
      height: 70%;
      pointer-events: auto;
      touch-action: none;
    }

    @media (max-width: 768px), (pointer: coarse) {
      #hotbar { bottom: 160px; }
      #mobile-controls { display: block; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="loading">Initializing...</div>

  <div id="debug-panel" class="hidden">
    <button id="close-debug">x</button>
    <div>Status: <span id="status-text">Loading</span></div>
    <div>FPS: <span id="fps">0</span></div>
    <div>Pos: <span id="player-pos">X:0 Y:0 Z:0</span></div>
    <div>Ground: <span id="on-ground">No</span></div>
  </div>

  <button id="toggle-debug">Debug</button>

  <div id="crosshair"></div>

  <div id="ui">
    <button id="close-ui">x</button>
    <h3>Controls</h3>
    <div>WASD - Move</div>
    <div>Shift - Sprint</div>
    <div>Space - Jump</div>
    <div>Mouse - Look</div>
    <div>Left Click - Break</div>
    <div>Right Click - Place</div>
    <div>1-8 - Select Block</div>
    <div style="margin-top:10px; font-size:11px; opacity:0.8;">Click screen to play</div>
  </div>

  <div id="hotbar"></div>

  <div id="mobile-controls">
    <div id="joystick">
      <div id="joystick-knob"></div>
    </div>
    <button id="jumpBtn" class="mobile-btn">JUMP</button>
    <button id="placeBtn" class="mobile-btn">PLACE</button>
    <button id="breakBtn" class="mobile-btn">BREAK</button>
    <div id="lookArea"></div>
  </div>

  <script>
    (async function startGame() {
      const loadingEl = document.getElementById('loading');
      const debugPanel = document.getElementById('debug-panel');
      const toggleDebug = document.getElementById('toggle-debug');
      const hotbar = document.getElementById('hotbar');

      function setLoading(msg) {
        if (loadingEl) loadingEl.textContent = msg;
        console.log('[Game]', msg);
      }

      function hideLoading() {
        if (loadingEl) loadingEl.classList.add('hidden');
        if (debugPanel) debugPanel.classList.remove('hidden');
        if (toggleDebug) toggleDebug.style.display = 'block';
      }

      function fatalError(msg) {
        if (loadingEl) loadingEl.textContent = 'Error: ' + msg;
        console.error('[Game] Fatal:', msg);
      }

      // Wire up UI close buttons
      const closeDebug = document.getElementById('close-debug');
      if (closeDebug) closeDebug.addEventListener('click', () => {
        if (debugPanel) debugPanel.classList.add('hidden');
        if (toggleDebug) toggleDebug.style.display = 'block';
      });
      if (toggleDebug) toggleDebug.addEventListener('click', () => {
        if (debugPanel) debugPanel.classList.remove('hidden');
        toggleDebug.style.display = 'none';
      });
      const closeUi = document.getElementById('close-ui');
      const uiPanel = document.getElementById('ui');
      if (closeUi) closeUi.addEventListener('click', () => {
        if (uiPanel) uiPanel.classList.add('hidden');
      });

      // Load Three.js
      setLoading('Loading Three.js...');
      const cdnSources = [
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
        'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
        'https://unpkg.com/three@0.128.0/build/three.min.js'
      ];

      for (const src of cdnSources) {
        if (window.THREE) break;
        try {
          await new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = src;
            s.onload = resolve;
            s.onerror = () => reject(new Error('Failed: ' + src));
            document.head.appendChild(s);
          });
        } catch (e) {
          console.warn(e.message);
        }
      }

      if (!window.THREE) {
        fatalError('Could not load Three.js. Check your internet connection.');
        return;
      }

      // Check WebGL availability
      try {
        const testCanvas = document.createElement('canvas');
        const hasWebGL = !!(window.WebGLRenderingContext &&
          (testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl')));
        if (!hasWebGL) {
          fatalError('WebGL not supported. Enable hardware acceleration in your browser settings.');
          return;
        }
      } catch (e) {
        fatalError('WebGL check failed: ' + e.message);
        return;
      }

      const THREE = window.THREE;
      setLoading('Initializing renderer...');

      // Get the canvas element
      const canvas = document.getElementById('gameCanvas');
      if (!canvas) {
        fatalError('Canvas element not found.');
        return;
      }

      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 40, 80);

      // Camera
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);

      // Renderer
      let renderer;
      try {
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setClearColor(0x87CEEB, 1);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      } catch (e) {
        fatalError('Renderer init failed: ' + e.message);
        return;
      }

      canvas.addEventListener('webglcontextlost', (e) => {
        e.preventDefault();
        setLoading('WebGL context lost. Refresh to restore.');
        if (loadingEl) loadingEl.classList.remove('hidden');
      });

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.65));

      const sun = new THREE.DirectionalLight(0xfff9e6, 0.9);
      sun.position.set(60, 90, 40);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024, 1024);
      sun.shadow.camera.left = -60;
      sun.shadow.camera.right = 60;
      sun.shadow.camera.top = 60;
      sun.shadow.camera.bottom = -60;
      scene.add(sun);

      scene.add(new THREE.HemisphereLight(0x87CEEB, 0x6B5D3F, 0.4));

      // Materials
      const materials = {
        grass: [
          new THREE.MeshLambertMaterial({ color: 0x4a7a2f }),
          new THREE.MeshLambertMaterial({ color: 0x4a7a2f }),
          new THREE.MeshLambertMaterial({ color: 0x5cb230 }),
          new THREE.MeshLambertMaterial({ color: 0x7d5f35 }),
          new THREE.MeshLambertMaterial({ color: 0x4a7a2f }),
          new THREE.MeshLambertMaterial({ color: 0x4a7a2f })
        ],
        dirt:        new THREE.MeshLambertMaterial({ color: 0x7d5f35 }),
        stone:       new THREE.MeshLambertMaterial({ color: 0x7a7a7a }),
        wood:        new THREE.MeshLambertMaterial({ color: 0x6b4423 }),
        leaves:      new THREE.MeshLambertMaterial({ color: 0x2d8b2d, transparent: true, opacity: 0.9 }),
        sand:        new THREE.MeshLambertMaterial({ color: 0xe8c998 }),
        cobblestone: new THREE.MeshLambertMaterial({ color: 0x5a5a5a }),
        planks:      new THREE.MeshLambertMaterial({ color: 0xb8935f }),
        water:       new THREE.MeshLambertMaterial({ color: 0x3d8fd1, transparent: true, opacity: 0.75 })
      };

      // World state
      const world = new Map();
      const collidableMeshes = [];
      const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

      function getKey(x, y, z) {
        return `${x}|${y}|${z}`;
      }

      function addBlock(x, y, z, type) {
        const key = getKey(x, y, z);
        if (world.has(key)) return;
        const mesh = new THREE.Mesh(blockGeometry, materials[type]);
        mesh.position.set(x, y, z);
        mesh.castShadow = (type !== 'water');
        mesh.receiveShadow = true;
        mesh.userData.blockType = type;
        scene.add(mesh);
        world.set(key, { type, mesh });
        if (type !== 'water') collidableMeshes.push(mesh);
      }

      function removeBlock(x, y, z) {
        const key = getKey(x, y, z);
        const block = world.get(key);
        if (!block || block.type === 'water') return;
        scene.remove(block.mesh);
        const idx = collidableMeshes.indexOf(block.mesh);
        if (idx >= 0) collidableMeshes.splice(idx, 1);
        world.delete(key);
      }

      function groundHeight(x, z) {
        const n1 = Math.sin(x * 0.2) * Math.cos(z * 0.2);
        const n2 = Math.sin(x * 0.07 + 2.3) * Math.cos(z * 0.1 - 1.1);
        return Math.floor(6 + n1 * 2 + n2 * 3);
      }

      // World generation
      setLoading('Generating world...');

      (function generateWorld() {
        const isMob = window.matchMedia('(max-width: 768px)').matches ||
          /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        const size = isMob ? 14 : 20;
        const waterLevel = 5;

        for (let x = -size; x <= size; x++) {
          for (let z = -size; z <= size; z++) {
            const topY = groundHeight(x, z);
            const isBeach = topY <= waterLevel + 1;
            for (let y = 0; y <= topY; y++) {
              if (y === topY) addBlock(x, y, z, isBeach ? 'sand' : 'grass');
              else if (y >= topY - 2) addBlock(x, y, z, isBeach ? 'sand' : 'dirt');
              else addBlock(x, y, z, 'stone');
            }
            if (topY < waterLevel) {
              for (let y = topY + 1; y <= waterLevel; y++) addBlock(x, y, z, 'water');
            }
          }
        }
      })();

      // Player
      const player = {
        position: new THREE.Vector3(0, 12, 8),
        velocity: new THREE.Vector3(),
        speed: 0.12,
        sprintSpeed: 0.2,
        jumpForce: 0.24,
        gravity: 0.015,
        height: 1.7,
        radius: 0.3,
        onGround: false,
        bob: 0
      };

      camera.position.copy(player.position);
      camera.position.y += player.height;

      // Input state
      const keys = {};
      const look = { yaw: 0, pitch: 0, locked: false };
      const raycaster = new THREE.Raycaster();
      raycaster.far = 6;
      const upAxis = new THREE.Vector3(0, 1, 0);

      const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'cobblestone', 'planks'];
      let selectedBlock = 'grass';

      // Build hotbar
      hotbar.innerHTML = '';
      blockTypes.forEach((name, idx) => {
        const slot = document.createElement('div');
        slot.className = 'block-slot' + (idx === 0 ? ' selected' : '');
        const mat = Array.isArray(materials[name]) ? materials[name][2] : materials[name];
        slot.style.background = '#' + mat.color.getHexString();
        slot.innerHTML = `<div class="num">${idx + 1}</div>`;
        slot.addEventListener('click', () => {
          selectedBlock = name;
          [...hotbar.children].forEach((c, i) => {
            c.className = 'block-slot' + (i === idx ? ' selected' : '');
          });
        });
        hotbar.appendChild(slot);
      });

      // Helpers
      function solidAt(x, y, z) {
        const block = world.get(getKey(Math.round(x), Math.floor(y), Math.round(z)));
        return !!block && block.type !== 'water';
      }

      function playerCollides(pos) {
        const yMin = pos.y;
        const yMax = pos.y + player.height;
        const corners = [
          [pos.x - player.radius, pos.z - player.radius],
          [pos.x + player.radius, pos.z - player.radius],
          [pos.x - player.radius, pos.z + player.radius],
          [pos.x + player.radius, pos.z + player.radius]
        ];
        for (const [px, pz] of corners) {
          for (let y = Math.floor(yMin); y <= Math.floor(yMax); y++) {
            if (solidAt(px, y, pz)) return true;
          }
        }
        return false;
      }

      function handleBlockAction(isBreak) {
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        const hits = raycaster.intersectObjects(collidableMeshes, false);
        if (!hits.length) return;
        const hit = hits[0];
        const target = hit.object.position;
        if (isBreak) {
          removeBlock(target.x, target.y, target.z);
        } else {
          const placePos = target.clone().add(hit.face.normal);
          addBlock(Math.round(placePos.x), Math.round(placePos.y), Math.round(placePos.z), selectedBlock);
        }
      }

      // Keyboard events
      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        const n = Number(e.key);
        if (n >= 1 && n <= blockTypes.length) {
          selectedBlock = blockTypes[n - 1];
          [...hotbar.children].forEach((c, i) => {
            c.className = 'block-slot' + (i === n - 1 ? ' selected' : '');
          });
        }
      });
      document.addEventListener('keyup', (e) => { keys[e.code] = false; });

      // Mouse events
      canvas.addEventListener('click', () => {
        if (!look.locked) canvas.requestPointerLock();
      });
      document.addEventListener('pointerlockchange', () => {
        look.locked = document.pointerLockElement === canvas;
      });
      document.addEventListener('mousemove', (e) => {
        if (!look.locked) return;
        look.yaw += e.movementX * 0.002;
        look.pitch -= e.movementY * 0.002;
        look.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, look.pitch));
      });
      document.addEventListener('mousedown', (e) => {
        if (!look.locked) return;
        e.preventDefault();
        if (e.button === 0) handleBlockAction(true);
        if (e.button === 2) handleBlockAction(false);
      });
      document.addEventListener('contextmenu', (e) => e.preventDefault());

      // Mobile joystick
      const joystickEl = document.getElementById('joystick');
      const joystickKnob = document.getElementById('joystick-knob');
      const joystick = { active: false, deltaX: 0, deltaY: 0, startX: 0, startY: 0 };

      if (joystickEl) {
        joystickEl.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const t = e.changedTouches[0];
          joystick.active = true;
          joystick.startX = t.clientX;
          joystick.startY = t.clientY;
          joystick.deltaX = 0;
          joystick.deltaY = 0;
        }, { passive: false });

        joystickEl.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const t = e.changedTouches[0];
          const dx = t.clientX - joystick.startX;
          const dy = t.clientY - joystick.startY;
          const maxDist = 40;
          const dist = Math.min(Math.hypot(dx, dy), maxDist);
          const angle = Math.atan2(dy, dx);
          joystick.deltaX = Math.cos(angle) * dist / maxDist;
          joystick.deltaY = Math.sin(angle) * dist / maxDist;
          if (joystickKnob) {
            const ox = Math.cos(angle) * dist;
            const oy = Math.sin(angle) * dist;
            joystickKnob.style.transform = `translate(calc(-50% + ${ox}px), calc(-50% + ${oy}px))`;
          }
        }, { passive: false });

        const endJoystick = () => {
          joystick.active = false;
          joystick.deltaX = 0;
          joystick.deltaY = 0;
          if (joystickKnob) joystickKnob.style.transform = 'translate(-50%, -50%)';
        };
        joystickEl.addEventListener('touchend', endJoystick);
        joystickEl.addEventListener('touchcancel', endJoystick);
      }

      // Mobile look area
      const lookAreaEl = document.getElementById('lookArea');
      const lookTouch = { active: false, lastX: 0, lastY: 0, id: null };

      if (lookAreaEl) {
        lookAreaEl.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const t = e.changedTouches[0];
          lookTouch.active = true;
          lookTouch.lastX = t.clientX;
          lookTouch.lastY = t.clientY;
          lookTouch.id = t.identifier;
        }, { passive: false });

        lookAreaEl.addEventListener('touchmove', (e) => {
          e.preventDefault();
          for (const t of e.changedTouches) {
            if (t.identifier === lookTouch.id) {
              look.yaw += (t.clientX - lookTouch.lastX) * 0.004;
              look.pitch -= (t.clientY - lookTouch.lastY) * 0.004;
              look.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, look.pitch));
              lookTouch.lastX = t.clientX;
              lookTouch.lastY = t.clientY;
            }
          }
        }, { passive: false });

        lookAreaEl.addEventListener('touchend', () => { lookTouch.active = false; });
        lookAreaEl.addEventListener('touchcancel', () => { lookTouch.active = false; });
      }

      // Mobile action buttons
      const jumpBtn = document.getElementById('jumpBtn');
      const placeBtn = document.getElementById('placeBtn');
      const breakBtn = document.getElementById('breakBtn');
      if (jumpBtn) {
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; }, { passive: false });
        jumpBtn.addEventListener('touchend', () => { keys['Space'] = false; });
      }
      if (placeBtn) {
        placeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleBlockAction(false); }, { passive: false });
      }
      if (breakBtn) {
        breakBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleBlockAction(true); }, { passive: false });
      }

      // Resize handler
      function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);

      // Update loop
      function update() {
        const speed = keys['ShiftLeft'] ? player.sprintSpeed : player.speed;
        const move = new THREE.Vector3();
        let moving = false;

        if (keys['KeyW']) { move.z -= speed; moving = true; }
        if (keys['KeyS']) { move.z += speed; moving = true; }
        if (keys['KeyA']) { move.x -= speed; moving = true; }
        if (keys['KeyD']) { move.x += speed; moving = true; }

        if (joystick.active && (joystick.deltaX !== 0 || joystick.deltaY !== 0)) {
          move.x += joystick.deltaX * speed;
          move.z += joystick.deltaY * speed;
          moving = true;
        }

        if (keys['Space'] && player.onGround) {
          player.velocity.y = player.jumpForce;
          player.onGround = false;
        }

        move.applyAxisAngle(upAxis, look.yaw);
        player.velocity.y -= player.gravity;

        const tryX = player.position.clone();
        tryX.x += move.x;
        if (!playerCollides(tryX)) player.position.x = tryX.x;

        const tryZ = player.position.clone();
        tryZ.z += move.z;
        if (!playerCollides(tryZ)) player.position.z = tryZ.z;

        const tryY = player.position.clone();
        tryY.y += player.velocity.y;
        if (!playerCollides(tryY)) {
          player.position.y = tryY.y;
          player.onGround = false;
        } else {
          if (player.velocity.y < 0) player.onGround = true;
          player.velocity.y = 0;
        }

        // Fall reset
        if (player.position.y < -5) {
          player.position.set(0, 12, 8);
          player.velocity.set(0, 0, 0);
        }

        if (moving && player.onGround) player.bob += 0.2;
        const bobAmount = (moving && player.onGround) ? Math.sin(player.bob) * 0.08 : 0;

        camera.position.copy(player.position);
        camera.position.y += player.height - 0.25 + bobAmount;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = look.yaw;
        camera.rotation.x = look.pitch;

        // Update debug display
        const posEl = document.getElementById('player-pos');
        if (posEl) {
          posEl.textContent = `X:${player.position.x.toFixed(1)} Y:${player.position.y.toFixed(1)} Z:${player.position.z.toFixed(1)}`;
        }
        const groundEl = document.getElementById('on-ground');
        if (groundEl) groundEl.textContent = player.onGround ? 'Yes' : 'No';
      }

      // FPS tracking
      let lastTime = performance.now();
      let frameCount = 0;
      let fpsTimer = 0;

      function animate(now) {
        requestAnimationFrame(animate);
        const delta = now - lastTime;
        lastTime = now;
        fpsTimer += delta;
        frameCount++;
        if (fpsTimer >= 1000) {
          const fpsEl = document.getElementById('fps');
          if (fpsEl) fpsEl.textContent = frameCount;
          frameCount = 0;
          fpsTimer = 0;
        }
        update();
        renderer.render(scene, camera);
      }

      // Ready â€” hide loading overlay and start
      setLoading('World ready! Click to play.');
      setTimeout(() => { hideLoading(); }, 1500);
      animate(performance.now());
    })();
  </script>
</body>
</html>
